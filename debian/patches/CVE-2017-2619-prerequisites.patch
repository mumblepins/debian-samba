Description: This patch is a consolidation of several commits (8234c6a, 629e302, 0a3b024, bc3714f, d302cb6, 94f7d0c, 33ead72, 66ee839, 77cacee) cherry-picked from Samba's upstream Git repository (v3-6-stable branch) because they contain changes which are dependencies of the CVE-2017-2619 patch (which upstream based upon version 3.6.25); this was done in lieu of upgrading wheezy from Samba 3.6.6 to 3.6.25
origin: upstream , https://git.samba.org/?p=samba.git;a=commitdiff;h=8234c6a , https://git.samba.org/?p=samba.git;a=commitdiff;h=629e302 , https://git.samba.org/?p=samba.git;a=commitdiff;h=0a3b024 , https://git.samba.org/?p=samba.git;a=commitdiff;h=bc3714f , https://git.samba.org/?p=samba.git;a=commitdiff;h=d302cb6 , https://git.samba.org/?p=samba.git;a=commitdiff;h=94f7d0c , https://git.samba.org/?p=samba.git;a=commitdiff;h=33ead72 , https://git.samba.org/?p=samba.git;a=commitdiff;h=66ee839 , https://git.samba.org/?p=samba.git;a=commitdiff;h=77cacee

--- samba-3.6.6.orig/source3/smbd/dir.c
+++ samba-3.6.6/source3/smbd/dir.c
@@ -50,6 +50,8 @@
 	struct name_cache_entry *name_cache;
 	unsigned int name_cache_index;
 	unsigned int file_number;
+	files_struct *fsp; /* Back pointer to containing fsp, only
+			      set from OpenDir_fsp(). */
 };
 
 struct dptr_struct {
@@ -1428,7 +1430,9 @@
 
 	if (fsp->is_directory && fsp->fh->fd != -1) {
 		dirp->dir = SMB_VFS_FDOPENDIR(fsp, mask, attr);
-		if (dirp->dir == NULL) {
+		if (dirp->dir != NULL) {
+			dirp->fsp = fsp;
+		} else {
 			DEBUG(10,("OpenDir_fsp: SMB_VFS_FDOPENDIR on %s returned "
 				"NULL (%s)\n",
 				dirp->dir_path,
--- samba-3.6.6.orig/source3/modules/vfs_dirsort.c
+++ samba-3.6.6/source3/modules/vfs_dirsort.c
@@ -30,40 +30,60 @@
 struct dirsort_privates {
 	long pos;
 	SMB_STRUCT_DIRENT *directory_list;
-	long number_of_entries;
-	time_t mtime;
+	unsigned int number_of_entries;
+	struct timespec mtime;
 	SMB_STRUCT_DIR *source_directory;
-	int fd;
+	files_struct *fsp; /* If open via FDOPENDIR. */
+	struct smb_filename *smb_fname; /* If open via OPENDIR */
 };
 
 static void free_dirsort_privates(void **datap) {
-	struct dirsort_privates *data = (struct dirsort_privates *) *datap;
-	SAFE_FREE(data->directory_list);
-	SAFE_FREE(data);
-	*datap = NULL;
-
-	return;
+	TALLOC_FREE(*datap);
 }
 
-static bool open_and_sort_dir (vfs_handle_struct *handle)
+static bool get_sorted_dir_mtime(vfs_handle_struct *handle,
+				struct dirsort_privates *data,
+				struct timespec *ret_mtime)
 {
-	SMB_STRUCT_DIRENT *dp;
-	struct stat dir_stat;
-	long current_pos;
-	struct dirsort_privates *data = NULL;
+	int ret;
+	struct timespec mtime;
 
-	SMB_VFS_HANDLE_GET_DATA(handle, data, struct dirsort_privates,
-				return false);
+	if (data->fsp) {
+		ret = fsp_stat(data->fsp);
+		mtime = data->fsp->fsp_name->st.st_ex_mtime;
+	} else {
+		ret = SMB_VFS_STAT(handle->conn, data->smb_fname);
+		mtime = data->smb_fname->st.st_ex_mtime;
+	}
+
+	if (ret == -1) {
+		return false;
+	}
+
+	*ret_mtime = mtime;
+
+	return true;
+}
+
+static bool open_and_sort_dir(vfs_handle_struct *handle,
+				struct dirsort_privates *data)
+{
+	unsigned int i = 0;
+	unsigned int total_count = 0;
 
 	data->number_of_entries = 0;
 
-	if (fstat(data->fd, &dir_stat) == 0) {
-		data->mtime = dir_stat.st_mtime;
+	if (get_sorted_dir_mtime(handle, data, &data->mtime) == false) {
+		return false;
 	}
 
 	while (SMB_VFS_NEXT_READDIR(handle, data->source_directory, NULL)
 	       != NULL) {
-		data->number_of_entries++;
+		total_count++;
+	}
+
+	if (total_count == 0) {
+		return false;
 	}
 
 	/* Open the underlying directory and count the number of entries
@@ -71,21 +91,26 @@
 	SMB_VFS_NEXT_REWINDDIR(handle, data->source_directory);
 
 	/* Set up an array and read the directory entries into it */
-	SAFE_FREE(data->directory_list); /* destroy previous cache if needed */
-	data->directory_list = (SMB_STRUCT_DIRENT *)SMB_MALLOC(
-		data->number_of_entries * sizeof(SMB_STRUCT_DIRENT));
+	TALLOC_FREE(data->directory_list); /* destroy previous cache if needed */
+	data->directory_list = talloc_zero_array(data,
+						 SMB_STRUCT_DIRENT,
+						 total_count);
 	if (!data->directory_list) {
 		return false;
 	}
-	current_pos = data->pos;
-	data->pos = 0;
-	while ((dp = SMB_VFS_NEXT_READDIR(handle, data->source_directory,
-					  NULL)) != NULL) {
-		data->directory_list[data->pos++] = *dp;
+	for (i = 0; i < total_count; i++) {
+		SMB_STRUCT_DIRENT *dp = SMB_VFS_NEXT_READDIR(handle,
+						data->source_directory,
+						NULL);
+		if (dp == NULL) {
+			break;
+		}
+		data->directory_list[i] = *dp;
 	}
 
+	data->number_of_entries = i;
+
 	/* Sort the directory entries by name */
-	data->pos = current_pos;
 	TYPESAFE_QSORT(data->directory_list, data->number_of_entries, compare_dirent);
 	return true;
 }
@@ -94,12 +119,11 @@
 				       const char *fname, const char *mask,
 				       uint32 attr)
 {
+	NTSTATUS status;
 	struct dirsort_privates *data = NULL;
 
 	/* set up our private data about this directory */
-	data = (struct dirsort_privates *)SMB_MALLOC(
-		sizeof(struct dirsort_privates));
-
+	data = talloc_zero(handle->conn, struct dirsort_privates);
 	if (!data) {
 		return NULL;
 	}
@@ -107,20 +131,34 @@
 	data->directory_list = NULL;
 	data->pos = 0;
 
+	status = create_synthetic_smb_fname(data,
+					fname,
+					NULL,
+					NULL,
+					&data->smb_fname);
+	if (!NT_STATUS_IS_OK(status)) {
+		TALLOC_FREE(data);
+		return NULL;
+	}
+
 	/* Open the underlying directory and count the number of entries */
 	data->source_directory = SMB_VFS_NEXT_OPENDIR(handle, fname, mask,
 						      attr);
 
-	data->fd = dirfd(data->source_directory);
-
-	SMB_VFS_HANDLE_SET_DATA(handle, data, free_dirsort_privates,
-				struct dirsort_privates, return NULL);
+	if (data->source_directory == NULL) {
+		TALLOC_FREE(data);
+		return NULL;
+	}
 
-	if (!open_and_sort_dir(handle)) {
+	if (!open_and_sort_dir(handle, data)) {
 		SMB_VFS_NEXT_CLOSEDIR(handle,data->source_directory);
+		TALLOC_FREE(data);
 		return NULL;
 	}
 
+	SMB_VFS_HANDLE_SET_DATA(handle, data, free_dirsort_privates,
+				struct dirsort_privates, return NULL);
+
 	return data->source_directory;
 }
 
@@ -132,37 +170,35 @@
 	struct dirsort_privates *data = NULL;
 
 	/* set up our private data about this directory */
-	data = (struct dirsort_privates *)SMB_MALLOC(
-		sizeof(struct dirsort_privates));
-
+	data = talloc_zero(handle->conn, struct dirsort_privates);
 	if (!data) {
 		return NULL;
 	}
 
 	data->directory_list = NULL;
 	data->pos = 0;
+	data->fsp = fsp;
 
 	/* Open the underlying directory and count the number of entries */
 	data->source_directory = SMB_VFS_NEXT_FDOPENDIR(handle, fsp, mask,
 						      attr);
 
 	if (data->source_directory == NULL) {
-		SAFE_FREE(data);
+		TALLOC_FREE(data);
 		return NULL;
 	}
 
-	data->fd = dirfd(data->source_directory);
-
-	SMB_VFS_HANDLE_SET_DATA(handle, data, free_dirsort_privates,
-				struct dirsort_privates, return NULL);
-
-	if (!open_and_sort_dir(handle)) {
+	if (!open_and_sort_dir(handle, data)) {
 		SMB_VFS_NEXT_CLOSEDIR(handle,data->source_directory);
+		TALLOC_FREE(data);
 		/* fd is now closed. */
 		fsp->fh->fd = -1;
 		return NULL;
 	}
 
+	SMB_VFS_HANDLE_SET_DATA(handle, data, free_dirsort_privates,
+				struct dirsort_privates, return NULL);
+
 	return data->source_directory;
 }
 
@@ -171,21 +207,18 @@
 					  SMB_STRUCT_STAT *sbuf)
 {
 	struct dirsort_privates *data = NULL;
-	time_t current_mtime;
-	struct stat dir_stat;
+	struct timespec current_mtime;
 
 	SMB_VFS_HANDLE_GET_DATA(handle, data, struct dirsort_privates,
 				return NULL);
 
-	if (fstat(data->fd, &dir_stat) == -1) {
+	if (get_sorted_dir_mtime(handle, data, &current_mtime) == false) {
 		return NULL;
 	}
 
-	current_mtime = dir_stat.st_mtime;
-
 	/* throw away cache and re-read the directory if we've changed */
-	if (current_mtime > data->mtime) {
-		open_and_sort_dir(handle);
+	if (timespec_compare(&current_mtime, &data->mtime) > 1) {
+		open_and_sort_dir(handle, data);
 	}
 
 	if (data->pos >= data->number_of_entries) {
