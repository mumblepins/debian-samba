<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book xmlns:xi="http://www.w3.org/2003/XInclude" id="Samba-Developers-Guide">

<title>SAMBA Developers Guide</title>

<bookinfo>
<authorgroup>
	<editor>
<firstname>Jelmer</firstname><othername>R.</othername><surname>Vernooij</surname><othername>R.</othername>
<affiliation>
	<orgname>The Samba Team</orgname>
	<address format="linespecific"><email>jelmer@samba.org</email></address>
</affiliation></editor>
</authorgroup>
	
<abstract>
<para>
<emphasis>Last Update</emphasis> : Fri Oct 10 00:59:58 CEST 2003
</para>

<para>
This book is a collection of documents that might be useful for 
people developing samba or those interested in doing so.
It's nothing more than a collection of documents written by samba developers about 
the internals of various parts of samba and the SMB protocol. It's still (and will always be) incomplete.
The most recent version of this document
can be found at <ulink url="http://devel.samba.org/">http://devel.samba.org/</ulink>.
</para>

<para>
This documentation is distributed under the GNU General Public License (GPL) 
version 2.  A copy of the license is included with the Samba source
distribution.  A copy can be found on-line at <ulink url="http://www.fsf.org/licenses/gpl.txt">http://www.fsf.org/licenses/gpl.txt</ulink>
</para>

<warning>
	<para>This document is incomplete and unmaintained. It is merely a 
	collection of development-related notes.</para>
</warning>

</abstract>

</bookinfo>

<preface>
  <title>Attribution</title>
  <para><link linkend="unix-smb">NetBIOS in a Unix World</link>
	<itemizedlist>	<listitem><para>Andrew Tridgell</para></listitem>
	</itemizedlist>
</para>
  <para><link linkend="ntdomain">NT Domain RPC's</link>
	<itemizedlist>	<listitem><para>Luke Leighton<ulink noescape="1" url="mailto:lkcl@switchboard.net"/></para></listitem>
	<listitem><para>Paul Ashton<ulink noescape="1" url="mailto:paul@argo.demon.co.uk"/></para></listitem>
	<listitem><para>Duncan Stansfield<ulink noescape="1" url="mailto:duncans@sco.com"/></para></listitem>
	</itemizedlist>
</para>
  <para><link linkend="architecture">Samba Architecture</link>
	<itemizedlist>	<listitem><para>Dan Shearer</para></listitem>
	</itemizedlist>
</para>
  <para><link linkend="debug">The samba DEBUG system</link>
	<itemizedlist>	<listitem><para>Chris Hertel</para></listitem>
	</itemizedlist>
</para>
  <para><link linkend="internals">Samba Internals</link>
	<itemizedlist>	<listitem><para>David Chappell<ulink noescape="1" url="mailto:David.Chappell@mail.trincoll.edu"/></para></listitem>
	</itemizedlist>
</para>
  <para><link linkend="CodingSuggestions">Coding Suggestions</link>
	<itemizedlist>	<listitem><para>Steve French</para></listitem>
	<listitem><para>Simo Sorce</para></listitem>
	<listitem><para>Andrew Bartlett</para></listitem>
	<listitem><para>Tim Potter</para></listitem>
	<listitem><para>Martin Pool</para></listitem>
	</itemizedlist>
</para>
  <para><link linkend="contributing">Contributing code</link>
	<itemizedlist>	<listitem><para>Jelmer R.  Vernooij<ulink noescape="1" url="mailto:jelmer@samba.org"/></para></listitem>
	</itemizedlist>
</para>
  <para><link linkend="modules">Modules</link>
	<itemizedlist>	<listitem><para>Jelmer Vernooij<ulink noescape="1" url="mailto:jelmer@samba.org"/></para></listitem>
	</itemizedlist>
</para>
  <para><link linkend="rpc-plugin">RPC Pluggable Modules</link>
	<itemizedlist>	<listitem><para>Anthony Liguori<ulink noescape="1" url="mailto:aliguor@us.ibm.com"/></para></listitem>
	<listitem><para>Jelmer Vernooij<ulink noescape="1" url="mailto:jelmer@samba.org"/></para></listitem>
	</itemizedlist>
</para>
  <para><link linkend="vfs">VFS Modules</link>
	<itemizedlist>	<listitem><para>Alexander Bokovoy<ulink noescape="1" url="mailto:ab@samba.org"/></para></listitem>
	<listitem><para>Stefan Metzmacher<ulink noescape="1" url="mailto:metze@samba.org"/></para></listitem>
	</itemizedlist>
</para>
  <para><link linkend="parsing">The smb.conf file</link>
	<itemizedlist>	<listitem><para>Chris Hertel</para></listitem>
	</itemizedlist>
</para>
  <para><link linkend="wins">Samba WINS Internals</link>
	<itemizedlist>	<listitem><para>Gerald Carter</para></listitem>
	</itemizedlist>
</para>
  <para><link linkend="pwencrypt">LanMan and NT Password Encryption</link>
	<itemizedlist>	<listitem><para>Jeremy Allison<ulink noescape="1" url="mailto:samba@samba.org"/></para></listitem>
	</itemizedlist>
</para>
  <para><link linkend="tracing">Tracing samba system calls</link>
	<itemizedlist>	<listitem><para>Andrew Tridgell</para></listitem>
	</itemizedlist>
</para>
  <para><link linkend="devprinting">Samba Printing Internals</link>
	<itemizedlist>	<listitem><para>Gerald Carter</para></listitem>
	</itemizedlist>
</para>
  <para><link linkend="Packaging">Notes to packagers</link>
	<itemizedlist>	<listitem><para>Jelmer Vernooij</para></listitem>
	</itemizedlist>
</para>
</preface>

<?latex \cleardoublepage ?>

<!-- Contents -->
<toc/>

<?latex \pagenumbering{arabic} ?>
<!-- Chapters -->
<part>
	<title>The protocol</title>

	<chapter id="unix-smb">
<chapterinfo>
	<author>
		<firstname>Andrew</firstname><surname>Tridgell</surname>
	</author>
	<pubdate>April 1995</pubdate>
</chapterinfo>

<title>NetBIOS in a Unix World</title>

<sect1>
<title>Introduction</title>
<para>
This is a short document that describes some of the issues that
confront a SMB implementation on unix, and how Samba copes with
them. They may help people who are looking at unix&lt;-&gt;PC
interoperability.
</para>

<para>
It was written to help out a person who was writing a paper on unix to
PC connectivity.
</para>

</sect1>

<sect1>
<title>Usernames</title>
<para>
The SMB protocol has only a loose username concept. Early SMB
protocols (such as CORE and COREPLUS) have no username concept at
all. Even in later protocols clients often attempt operations
(particularly printer operations) without first validating a username
on the server.
</para>

<para>
Unix security is based around username/password pairs. A unix box
should not allow clients to do any substantive operation without some
sort of validation. 
</para>

<para>
The problem mostly manifests itself when the unix server is in "share
level" security mode. This is the default mode as the alternative
"user level" security mode usually forces a client to connect to the
server as the same user for each connected share, which is
inconvenient in many sites.
</para>

<para>
In "share level" security the client normally gives a username in the
"session setup" protocol, but does not supply an accompanying
password. The client then connects to resources using the "tree
connect" protocol, and supplies a password. The problem is that the
user on the PC types the username and the password in different
contexts, unaware that they need to go together to give access to the
server. The username is normally the one the user typed in when they
"logged onto" the PC (this assumes Windows for Workgroups). The
password is the one they chose when connecting to the disk or printer.
</para>

<para>
The user often chooses a totally different username for their login as
for the drive connection. Often they also want to access different
drives as different usernames. The unix server needs some way of
divining the correct username to combine with each password.
</para>

<para>
Samba tries to avoid this problem using several methods. These succeed
in the vast majority of cases. The methods include username maps, the
service%user syntax, the saving of session setup usernames for later
validation and the derivation of the username from the service name
(either directly or via the user= option).
</para>

</sect1>

<sect1>
<title>File Ownership</title>

<para>
The commonly used SMB protocols have no way of saying "you can't do
that because you don't own the file". They have, in fact, no concept
of file ownership at all.
</para>

<para>
This brings up all sorts of interesting problems. For example, when
you copy a file to a unix drive, and the file is world writeable but
owned by another user the file will transfer correctly but will
receive the wrong date. This is because the utime() call under unix
only succeeds for the owner of the file, or root, even if the file is
world writeable. For security reasons Samba does all file operations
as the validated user, not root, so the utime() fails. This can stuff
up shared development diectories as programs like "make" will not get
file time comparisons right.
</para>

<para>
There are several possible solutions to this problem, including
username mapping, and forcing a specific username for particular
shares.
</para>

</sect1>

<sect1>
<title>Passwords</title>

<para>
Many SMB clients uppercase passwords before sending them. I have no
idea why they do this. Interestingly WfWg uppercases the password only
if the server is running a protocol greater than COREPLUS, so
obviously it isn't just the data entry routines that are to blame.
</para>

<para>
Unix passwords are case sensitive. So if users use mixed case
passwords they are in trouble.
</para>

<para>
Samba can try to cope with this by either using the "password level"
option which causes Samba to try the offered password with up to the
specified number of case changes, or by using the "password server"
option which allows Samba to do its validation via another machine
(typically a WinNT server).
</para>

<para>
Samba supports the password encryption method used by SMB
clients. Note that the use of password encryption in Microsoft
networking leads to password hashes that are "plain text equivalent".
This means that it is *VERY* important to ensure that the Samba
smbpasswd file containing these password hashes is only readable
by the root user. See the documentation ENCRYPTION.txt for more
details.
</para>

</sect1>

<sect1>
<title>Locking</title>
<para>
Since samba 2.2, samba supports other types of locking as well. This 
section is outdated.
</para>

<para>
The locking calls available under a DOS/Windows environment are much
richer than those available in unix. This means a unix server (like
Samba) choosing to use the standard fcntl() based unix locking calls
to implement SMB locking has to improvise a bit.
</para>

<para>
One major problem is that dos locks can be in a 32 bit (unsigned)
range. Unix locking calls are 32 bits, but are signed, giving only a 31
bit range. Unfortunately OLE2 clients use the top bit to select a
locking range used for OLE semaphores.
</para>

<para>
To work around this problem Samba compresses the 32 bit range into 31
bits by appropriate bit shifting. This seems to work but is not
ideal. In a future version a separate SMB lockd may be added to cope
with the problem.
</para>

<para>
It also doesn't help that many unix lockd daemons are very buggy and
crash at the slightest provocation. They normally go mostly unused in
a unix environment because few unix programs use byte range
locking. The stress of huge numbers of lock requests from dos/windows
clients can kill the daemon on some systems.
</para>

<para>
The second major problem is the "opportunistic locking" requested by
some clients. If a client requests opportunistic locking then it is
asking the server to notify it if anyone else tries to do something on
the same file, at which time the client will say if it is willing to
give up its lock. Unix has no simple way of implementing
opportunistic locking, and currently Samba has no support for it.
</para>

</sect1>

<sect1>
<title>Deny Modes</title>

<para>
When a SMB client opens a file it asks for a particular "deny mode" to
be placed on the file. These modes (DENY_NONE, DENY_READ, DENY_WRITE,
DENY_ALL, DENY_FCB and DENY_DOS) specify what actions should be
allowed by anyone else who tries to use the file at the same time. If
DENY_READ is placed on the file, for example, then any attempt to open
the file for reading should fail.
</para>

<para>
Unix has no equivalent notion. To implement this Samba uses either lock
files based on the files inode and placed in a separate lock
directory or a shared memory implementation. The lock file method 
is clumsy and consumes processing and file resources,
the shared memory implementation is vastly prefered and is turned on
by default for those systems that support it.
</para>

</sect1>

<sect1>
<title>Trapdoor UIDs</title>
<para>
A SMB session can run with several uids on the one socket. This
happens when a user connects to two shares with different
usernames. To cope with this the unix server needs to switch uids
within the one process. On some unixes (such as SCO) this is not
possible. This means that on those unixes the client is restricted to
a single uid.
</para>

<para>
Note that you can also get the "trapdoor uid" message for other
reasons. Please see the FAQ for details.
</para>

</sect1>

<sect1>
<title>Port numbers</title>
<para>
There is a convention that clients on sockets use high "unprivileged"
port numbers (&gt;1000) and connect to servers on low "privilegedg" port
numbers. This is enforced in Unix as non-root users can't open a
socket for listening on port numbers less than 1000.
</para>

<para>
Most PC based SMB clients (such as WfWg and WinNT) don't follow this
convention completely. The main culprit is the netbios nameserving on
udp port 137. Name query requests come from a source port of 137. This
is a problem when you combine it with the common firewalling technique
of not allowing incoming packets on low port numbers. This means that
these clients can't query a netbios nameserver on the other side of a
low port based firewall.
</para>

<para>
The problem is more severe with netbios node status queries. I've
found that WfWg, Win95 and WinNT3.5 all respond to netbios node status
queries on port 137 no matter what the source port was in the
request. This works between machines that are both using port 137, but
it means it's not possible for a unix user to do a node status request
to any of these OSes unless they are running as root. The answer comes
back, but it goes to port 137 which the unix user can't listen
on. Interestingly WinNT3.1 got this right - it sends node status
responses back to the source port in the request.
</para>

</sect1>

<sect1>
<title>Protocol Complexity</title>
<para>
There are many "protocol levels" in the SMB protocol. It seems that
each time new functionality was added to a Microsoft operating system,
they added the equivalent functions in a new protocol level of the SMB
protocol to "externalise" the new capabilities.
</para>

<para>
This means the protocol is very "rich", offering many ways of doing
each file operation. This means SMB servers need to be complex and
large. It also means it is very difficult to make them bug free. It is
not just Samba that suffers from this problem, other servers such as
WinNT don't support every variation of every call and it has almost
certainly been a headache for MS developers to support the myriad of
SMB calls that are available.
</para>

<para>
There are about 65 "top level" operations in the SMB protocol (things
like SMBread and SMBwrite). Some of these include hundreds of
sub-functions (SMBtrans has at least 120 sub-functions, like
DosPrintQAdd and NetSessionEnum). All of them take several options
that can change the way they work. Many take dozens of possible
"information levels" that change the structures that need to be
returned. Samba supports all but 2 of the "top level" functions. It
supports only 8 (so far) of the SMBtrans sub-functions. Even NT
doesn't support them all.
</para>

<para>
Samba currently supports up to the "NT LM 0.12" protocol, which is the
one preferred by Win95 and WinNT3.5. Luckily this protocol level has a
"capabilities" field which specifies which super-duper new-fangled
options the server suports. This helps to make the implementation of
this protocol level much easier.
</para>

<para>
There is also a problem with the SMB specications. SMB is a X/Open
spec, but the X/Open book is far from ideal, and fails to cover many
important issues, leaving much to the imagination. Microsoft recently
renamed the SMB protocol CIFS (Common Internet File System) and have 
published new specifications. These are far superior to the old 
X/Open documents but there are still undocumented calls and features. 
This specification is actively being worked on by a CIFS developers 
mailing list hosted by Microsft.
</para>
</sect1>
</chapter>
	<chapter id="ntdomain">
<chapterinfo>
	<author>
		<firstname>Luke</firstname><surname>Leighton</surname>
		<affiliation><address format="linespecific"><email>lkcl@switchboard.net</email></address></affiliation>
	</author>
	<author>
		<firstname>Paul</firstname><surname>Ashton</surname>
		<affiliation><address format="linespecific"><email>paul@argo.demon.co.uk</email></address></affiliation>
	</author>
	<author>
		<firstname>Duncan</firstname><surname>Stansfield</surname>
		<affiliation><address format="linespecific"><email>duncans@sco.com</email></address></affiliation>
	</author>

	<pubdate>01 November 97(version 0.0.24)</pubdate>
</chapterinfo>

<title>NT Domain RPC's</title>

<sect1>
<title>Introduction</title>


<para>
This document contains information to provide an NT workstation with login
services, without the need for an NT server. It is the sgml version of <ulink url="http://mailhost.cb1.com/~lkcl/cifsntdomain.txt">http://mailhost.cb1.com/~lkcl/cifsntdomain.txt</ulink>, controlled by Luke.
</para>

<para>
It should be possible to select a domain instead of a workgroup (in the NT
workstation's TCP/IP settings) and after the obligatory reboot, type in a
username, password, select a domain and successfully log in.  I would
appreciate any feedback on your experiences with this process, and any
comments, corrections and additions to this document.
</para>

<para>
The packets described here can be easily derived from (and are probably
better understood using) Netmon.exe.  You will need to use the version
of Netmon that matches your system, in order to correctly decode the
NETLOGON, lsarpc and srvsvc Transact pipes.  This document is derived from
NT Service Pack 1 and its corresponding version of Netmon.  It is intended
that an annotated packet trace be produced, which will likely be more
instructive than this document.
</para>

<para>
Also needed, to fully implement NT Domain Login Services, is the 
document describing the cryptographic part of the NT authentication.
This document is available from comp.protocols.smb; from the ntsecurity.net
digest and from the samba digest, amongst other sources.
</para>

<para>
A copy is available from:
</para>

<para><ulink url="http://ntbugtraq.rc.on.ca/SCRIPTS/WA.EXE?A2=ind9708;L=ntbugtraq;O=A;P=2935">http://ntbugtraq.rc.on.ca/SCRIPTS/WA.EXE?A2=ind9708;L=ntbugtraq;O=A;P=2935</ulink></para>

<para><ulink url="http://mailhost.cb1.com/~lkcl/crypt.html">http://mailhost.cb1.com/~lkcl/crypt.html</ulink></para>

<para>
A c-code implementation, provided by <ulink url="mailto:linus@incolumitas.se">Linus Nordberg</ulink>
of this protocol is available from:
</para>

<para><ulink url="http://samba.org/cgi-bin/mfs/01/digest/1997/97aug/0391.html">http://samba.org/cgi-bin/mfs/01/digest/1997/97aug/0391.html</ulink></para>
<para><ulink url="http://mailhost.cb1.com/~lkcl/crypt.txt">http://mailhost.cb1.com/~lkcl/crypt.txt</ulink></para>

<para>
Also used to provide debugging information is the Check Build version of
NT workstation, and enabling full debugging in NETLOGON.  This is
achieved by setting the following REG_SZ registry key to 0x1ffffff:
</para>

<para><filename moreinfo="none">HKLM\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters</filename></para>

<para><emphasis>Incorrect direct editing of the registry can cause your
machine to fail. Then again, so can incorrect implementation of this 
protocol. See "Liability:" above.</emphasis></para>

<para>
Bear in mind that each packet over-the-wire will have its origin in an
API call.  Therefore, there are likely to be structures, enumerations
and defines that are usefully documented elsewhere.
</para>

<para>
This document is by no means complete or authoritative.  Missing sections
include, but are not limited to:
</para>


<orderedlist inheritnum="ignore" continuation="restarts">

<listitem><para>Mappings of RIDs to usernames (and vice-versa).</para></listitem>

<listitem><para>What a User ID is and what a Group ID is.</para></listitem>

<listitem><para>The exact meaning/definition of various magic constants or enumerations.</para></listitem>

<listitem><para>The reply error code and use of that error code when a
workstation becomes a member of a domain (to be described later).  
Failure to return this error code will make the workstation report 
that it is already a member of the domain.</para></listitem>

<listitem><para>the cryptographic side of the NetrServerPasswordSet command, 
which would allow the workstation to change its password.  This password is
used to generate the long-term session key.  [It is possible to reject this
command, and keep the default workstation password].</para></listitem>

</orderedlist>

<sect2>
<title>Sources</title>

<simplelist type="vert">
<member>cket Traces from Netmonitor (Service Pack 1 and above)</member>
<member>ul Ashton and Luke Leighton's other "NT Domain" doc.</member>
<member>FS documentation - cifs6.txt</member>
<member>FS documentation - cifsrap2.txt</member>
</simplelist>

</sect2>

<sect2>
<title>Credits</title>

<simplelist type="vert"> 
<member>Paul Ashton: loads of work with Net Monitor; understanding the NT authentication system; reference implementation of the NT domain support on which this document is originally based.</member>
<member>Duncan Stansfield: low-level analysis of MSRPC Pipes.</member>
<member>Linus Nordberg: producing c-code from Paul's crypto spec.</member>
<member>Windows Sourcer development team</member>
</simplelist>

</sect2>

</sect1>

<sect1>
<title>Notes and Structures</title>

<sect2>
<title>Notes</title>

<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><para>
In the SMB Transact pipes, some "Structures", described here, appear to be
4-byte aligned with the SMB header, at their start.  Exactly which
"Structures" need aligning is not precisely known or documented.
</para></listitem>

<listitem><para>
In the UDP NTLOGON Mailslots, some "Structures", described here, appear to be
2-byte aligned with the start of the mailslot, at their start.
</para></listitem>

<listitem><para>
Domain SID is of the format S-revision-version-auth1-auth2...authN.
e.g S-1-5-123-456-789-123-456.  the 5 could be a sub-revision.
</para></listitem>

<listitem><para>
any undocumented buffer pointers must be non-zero if the string buffer it
refers to contains characters.  exactly what value they should be is unknown.
0x0000 0002 seems to do the trick to indicate that the buffer exists.  a
NULL buffer pointer indicates that the string buffer is of zero length.
If the buffer pointer is NULL, then it is suspected that the structure it
refers to is NOT put into (or taken out of) the SMB data stream.  This is
empirically derived from, for example, the LSA SAM Logon response packet,
where if the buffer pointer is NULL, the user information is not inserted
into the data stream.  Exactly what happens with an array of buffer pointers
is not known, although an educated guess can be made.
</para></listitem>

<listitem><para>
an array of structures (a container) appears to have a count and a pointer.
if the count is zero, the pointer is also zero.  no further data is put
into or taken out of the SMB data stream.  if the count is non-zero, then
the pointer is also non-zero.  immediately following the pointer is the
count again, followed by an array of container sub-structures.  the count
appears a third time after the last sub-structure.
</para></listitem>
</orderedlist>

</sect2>

<sect2>
<title>Enumerations</title>

<sect3>
<title>MSRPC Header type</title>
<para>command number in the msrpc packet header</para>

<variablelist>
<varlistentry>
	<term>MSRPC_Request:</term>
	<listitem><para>0x00</para></listitem>
</varlistentry>
<varlistentry>
	<term>MSRPC_Response:</term>
	<listitem><para>0x02</para></listitem>
</varlistentry>
<varlistentry>
	<term>MSRPC_Bind:</term>
	<listitem><para>0x0B</para></listitem>
</varlistentry>
<varlistentry>
	<term>MSRPC_BindAck:</term>
	<listitem><para>0x0C</para></listitem>
</varlistentry>
</variablelist>
</sect3>

<sect3>
<title>MSRPC Packet info</title>

<para>The meaning of these flags is undocumented</para>

<variablelist>
<varlistentry>
	<term>FirstFrag:</term>
	<listitem><para>0x01 </para></listitem>
</varlistentry>
<varlistentry>
	<term>LastFrag:</term>
	<listitem><para>0x02 </para></listitem>
</varlistentry>
<varlistentry>
	<term>NotaFrag:</term>
	<listitem><para>0x04  </para></listitem>
</varlistentry>
<varlistentry>
	<term>RecRespond:</term>
	<listitem><para>0x08  </para></listitem>
</varlistentry>
<varlistentry>
	<term>NoMultiplex:</term>
	<listitem><para>0x10  </para></listitem>
</varlistentry>
<varlistentry>
	<term>NotForIdemp:</term>
	<listitem><para>0x20  </para></listitem>
</varlistentry>
<varlistentry>
	<term>NotforBcast:</term>
	<listitem><para>0x40  </para></listitem>
</varlistentry>
<varlistentry>
	<term>NoUuid:</term>
	<listitem><para>0x80 </para></listitem>
</varlistentry>
</variablelist>

</sect3>

</sect2>

<sect2>
<title>Structures</title>

<sect3><title>VOID *</title>
<para>sizeof VOID* is 32 bits.</para>
</sect3>

<sect3><title>char</title>
<para>sizeof char is 8 bits.</para>
</sect3>

<sect3><title>UTIME</title>
<para>UTIME is 32 bits, indicating time in seconds since 01jan1970.  documented in cifs6.txt (section 3.5 page, page 30).</para>
</sect3>

<sect3><title>NTTIME</title>
<para>NTTIME is 64 bits.  documented in cifs6.txt (section 3.5 page, page 30).</para>
</sect3>

<sect3>
<title>DOM_SID (domain SID structure)</title>

<variablelist>

<varlistentry>
	<term>UINT32</term>
	<listitem><para>num of sub-authorities in domain SID</para></listitem>
</varlistentry>

<varlistentry>
	<term>UINT8</term>
	<listitem><para>SID revision number</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8</term>
	<listitem><para>num of sub-authorities in domain SID</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8[6]</term>
	<listitem><para>6 bytes for domain SID - Identifier Authority.</para></listitem>
</varlistentry>

<varlistentry>
	<term>UINT16[n_subauths]</term>
	<listitem><para>domain SID sub-authorities</para></listitem>
</varlistentry>

</variablelist>

<para><emphasis>Note: the domain SID is documented elsewhere.</emphasis>
</para>

</sect3>

<sect3>
<title>STR (string)</title>

<para>STR (string) is a char[] : a null-terminated string of ascii characters.</para>

</sect3>

<sect3>
<title>UNIHDR (unicode string header) </title>

<variablelist>

<varlistentry>
	<term>UINT16</term>
	<listitem><para>length of unicode string</para></listitem>
</varlistentry>

<varlistentry>
	<term>UINT16</term>
	<listitem><para>max length of unicode string</para></listitem>
</varlistentry>

<varlistentry>
	<term>UINT32</term>
	<listitem><para>4 - undocumented.</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>
<title>UNIHDR2 (unicode string header plus buffer pointer)</title>

<variablelist>

<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>unicode string header</para></listitem>
</varlistentry>


<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>
<title>UNISTR (unicode string)</title>

<variablelist>

<varlistentry>
	<term>UINT16[]</term>
	<listitem><para>null-terminated string of unicode characters.</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>
<title>NAME (length-indicated unicode string)</title>

<variablelist>

<varlistentry>
	<term>UINT32</term>
	<listitem><para>length of unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16[]</term>
	<listitem><para>null-terminated string of unicode characters.</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>
<title>UNISTR2 (aligned unicode string)</title>

<variablelist>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>padding to get unicode string 4-byte aligned with the start of the SMB header.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>max length of unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - undocumented</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>length of unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16[]</term>
	<listitem><para>string of uncode characters</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>
<title>OBJ_ATTR (object attributes)</title>

<variablelist>
<varlistentry>
	<term>UINT32</term>
<listitem><para>0x18 - length (in bytes) including the length field.</para></listitem></varlistentry>
<varlistentry>
	<term>VOID*</term>
<listitem><para>0 - root directory (pointer)</para></listitem></varlistentry>
<varlistentry>
	<term>VOID*</term>
<listitem><para>0 - object name (pointer)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>0 - attributes (undocumented)</para></listitem></varlistentry>
<varlistentry>
	<term>VOID*</term>
<listitem><para>0 - security descriptior (pointer)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - security quality of service</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>
<title>POL_HND (LSA policy handle)</title>

<variablelist>
<varlistentry>
	<term>char[20]</term>
	<listitem><para>policy handle</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>DOM_SID2 (domain SID structure, SIDS stored in unicode)</title>

<variablelist>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>5 - SID type</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - undocumented</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR2</term>
	<listitem><para>domain SID unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>domain SID unicode string</para></listitem>
</varlistentry>
</variablelist>

<para><emphasis>Note:	there is a conflict between the unicode string header and the unicode string itself as to which to use to indicate string length.  this will need to be resolved.</emphasis></para>

<para><emphasis>Note:	the SID type indicates, for example, an alias; a well-known group etc. this is documented somewhere.</emphasis></para>

</sect3>

<sect3>
<title>DOM_RID (domain RID structure)</title>

<variablelist>
<varlistentry>
	<term>UINT32</term>
<listitem><para>5 - well-known SID.  1 - user SID (see ShowACLs)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>5 - undocumented</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>domain RID </para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - domain index out of above reference domains</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>LOG_INFO (server, account, client structure)</title>

<para><emphasis>Note:	logon server name starts with two '\' characters and is upper case.</emphasis></para>

<para><emphasis>Note:	account name is the logon client name from the LSA Request Challenge, with a $ on the end of it, in upper case.</emphasis></para>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon server unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>account name unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>sec_chan - security channel type</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon client machine unicode string</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>CLNT_SRV (server, client names structure)</title>

<para><emphasis>Note:	logon server name starts with two '\' characters and is upper case.</emphasis></para>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon server unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon client machine unicode string</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>CREDS (credentials + time stamp)</title>

<variablelist>
<varlistentry>
	<term>char[8]</term>
	<listitem><para>credentials</para></listitem>
</varlistentry>
<varlistentry>
	<term>UTIME</term>
	<listitem><para>time stamp</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>CLNT_INFO2 (server, client structure, client credentials)</title>

<para><emphasis>Note: whenever this structure appears in a request, you must take a copy of the client-calculated credentials received, because they will beused in subsequent credential checks.  the presumed intention is to
	maintain an authenticated request/response trail.</emphasis></para>

<variablelist>
<varlistentry>
	<term>CLNT_SRV</term>
	<listitem><para>client and server names</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>???? padding, for 4-byte alignment with SMB header.</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>pointer to client credentials.</para></listitem>
</varlistentry>
<varlistentry>
	<term>CREDS</term>
	<listitem><para>client-calculated credentials + client time</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>CLNT_INFO (server, account, client structure, client credentials)</title>
<para><emphasis>Note: whenever this structure appears in a request, you must take a copy of the client-calculated credentials received, because they will be used in subsequent credential checks.  the presumed intention is to maintain an authenticated request/response trail.</emphasis></para>

<variablelist>
<varlistentry>
	<term>LOG_INFO</term>
	<listitem><para>logon account info</para></listitem>
</varlistentry>
<varlistentry>
	<term>CREDS</term>
	<listitem><para>client-calculated credentials + client time</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>ID_INFO_1 (id info structure, auth level 1)</title>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>ptr_id_info_1</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>domain name unicode header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>param control</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT64</term>
	<listitem><para>logon ID</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>user name unicode header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>workgroup name unicode header</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[16]</term>
	<listitem><para>arc4 LM OWF Password</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[16]</term>
	<listitem><para>arc4 NT OWF Password</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>domain name unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>user name unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>workstation name unicode string</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>SAM_INFO (sam logon/logoff id info structure)</title>

<para><emphasis>Note: presumably, the return credentials is supposedly for the server to verify that the credential chain hasn't been compromised.</emphasis></para>

<variablelist>
<varlistentry>
	<term>CLNT_INFO2</term>
	<listitem><para>client identification/authentication info</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>pointer to return credentials.</para></listitem>
</varlistentry>
<varlistentry>
	<term>CRED</term>
	<listitem><para>return credentials - ignored.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>logon level</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>switch value</para></listitem>
</varlistentry>

</variablelist>

<para><programlisting format="linespecific">
        switch (switch_value)
        case 1:
        {
            ID_INFO_1     id_info_1;
        }
</programlisting></para>

</sect3>

<sect3>
<title>GID (group id info)</title>

<variablelist>
<varlistentry>
	<term>UINT32</term>
<listitem><para>group id</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>user attributes (only used by NT 3.1 and 3.51)</para></listitem></varlistentry>
</variablelist>

</sect3>

<sect3>
<title>DOM_REF (domain reference info)</title>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>num referenced domains?</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented domain name buffer pointer.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>32 - max number of entries</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>4 - num referenced domains?</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR2</term>
	<listitem><para>domain name unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR2[num_ref_doms-1]</term>
	<listitem><para>referenced domain unicode string headers</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>domain name unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>DOM_SID[num_ref_doms]</term>
	<listitem><para>referenced domain SIDs</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>DOM_INFO (domain info, levels 3 and 5 are the same))</title>

<variablelist>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>??? padding to get 4-byte alignment with start of SMB header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>domain name string length * 2</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>domain name string length * 2</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented domain name string buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
<listitem><para>undocumented domain SID string buffer pointer</para></listitem></varlistentry>
<varlistentry>
	<term>UNISTR2</term>
<listitem><para>domain name (unicode string)</para></listitem></varlistentry>
<varlistentry>
	<term>DOM_SID</term>
	<listitem><para>domain SID</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>USER_INFO (user logon info)</title>

<para><emphasis>Note: it would be nice to know what the 16 byte user session key is for.</emphasis></para>

<variablelist>
<varlistentry>
	<term>NTTIME</term>
	<listitem><para>logon time</para></listitem>
</varlistentry>
<varlistentry>
	<term>NTTIME</term>
	<listitem><para>logoff time</para></listitem>
</varlistentry>
<varlistentry>
	<term>NTTIME</term>
	<listitem><para>kickoff time</para></listitem>
</varlistentry>
<varlistentry>
	<term>NTTIME</term>
	<listitem><para>password last set time</para></listitem>
</varlistentry>
<varlistentry>
	<term>NTTIME</term>
	<listitem><para>password can change time</para></listitem>
</varlistentry>
<varlistentry>
	<term>NTTIME</term>
	<listitem><para>password must change time</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>username unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>user's full name unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>logon script unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>profile path unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>home directory unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>home directory drive unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>logon count</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>bad password count</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>User ID</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>Group ID</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>num groups</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer to groups.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>user flags</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[16]</term>
	<listitem><para>user session key</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>logon server unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>logon domain unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented logon domain id pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[40]</term>
	<listitem><para>40 undocumented padding bytes.  future expansion?</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - num_other_sids?</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>NULL - undocumented pointer to other domain SIDs.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>username unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>user's full name unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon script unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>profile path unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>home directory unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>home directory drive unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>num groups</para></listitem>
</varlistentry>
<varlistentry>
	<term>GID[num_groups]</term>
	<listitem><para>group info</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon server unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon domain unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>DOM_SID</term>
	<listitem><para>domain SID</para></listitem>
</varlistentry>
<varlistentry>
	<term>DOM_SID[num_sids]</term>
	<listitem><para>other domain SIDs?</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>SH_INFO_1_PTR (pointers to level 1 share info strings)</title>

<para><emphasis>Note:	see cifsrap2.txt section5, page 10.</emphasis></para>

<simplelist type="vert">
<member>0 for shi1_type indicates a  Disk.</member>
<member>1 for shi1_type indicates a  Print Queue.</member>
<member>2 for shi1_type indicates a  Device.</member>
<member>3 for shi1_type indicates an IPC pipe.</member>
<member>0x8000 0000 (top bit set in shi1_type) indicates a hidden share.</member>
</simplelist>

<variablelist>

<varlistentry>
	<term>VOID*</term>
	<listitem><para>shi1_netname - pointer to net name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>shi1_type    - type of share.  0 - undocumented.</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>shi1_remark  - pointer to comment.</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>
<title>SH_INFO_1_STR (level 1 share info strings)</title>

<variablelist>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>shi1_netname - unicode string of net name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>shi1_remark  - unicode string of comment.</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>SHARE_INFO_1_CTR</title>

<para>share container with 0 entries:</para>

<variablelist>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - EntriesRead</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - Buffer</para></listitem>
</varlistentry>
</variablelist>

<para>share container with &gt; 0 entries:</para>

<variablelist>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>EntriesRead</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>non-zero - Buffer</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>EntriesRead</para></listitem>
</varlistentry>
<varlistentry>
	<term>SH_INFO_1_PTR[EntriesRead]</term>
	<listitem><para>share entry pointers</para></listitem>
</varlistentry>
<varlistentry>
	<term>SH_INFO_1_STR[EntriesRead]</term>
	<listitem><para>share entry strings</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>padding to get unicode string 4-byte aligned with start of the SMB header.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>EntriesRead</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - padding</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>
<title>SERVER_INFO_101</title>

<para><emphasis>Note:	see cifs6.txt section 6.4 - the fields described therein will be of assistance here.  for example, the type listed below is the 	same as fServerType, which is described in 6.4.1. </emphasis></para>

<variablelist>
<varlistentry>
	<term>SV_TYPE_WORKSTATION</term>
	<listitem><para>0x00000001  All workstations</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_SERVER</term>
	<listitem><para>0x00000002  All servers</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_SQLSERVER</term>
	<listitem><para>0x00000004  Any server running with SQL server</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_DOMAIN_CTRL</term>
	<listitem><para>0x00000008  Primary domain controller</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_DOMAIN_BAKCTRL</term>
	<listitem><para>0x00000010  Backup domain controller</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_TIME_SOURCE</term>
	<listitem><para>0x00000020  Server running the timesource service</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_AFP</term>
	<listitem><para>0x00000040  Apple File Protocol servers</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_NOVELL</term>
	<listitem><para>0x00000080  Novell servers</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_DOMAIN_MEMBER</term>
	<listitem><para>0x00000100  Domain Member</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_PRINTQ_SERVER</term>
	<listitem><para>0x00000200  Server sharing print queue</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_DIALIN_SERVER</term>
	<listitem><para>0x00000400  Server running dialin service.</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_XENIX_SERVER</term>
	<listitem><para>0x00000800  Xenix server</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_NT</term>
	<listitem><para>0x00001000  NT server</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_WFW</term>
	<listitem><para>0x00002000  Server running Windows for </para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_SERVER_NT</term>
	<listitem><para>0x00008000  Windows NT non DC server</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_POTENTIAL_BROWSER</term>
	<listitem><para>0x00010000  Server that can run the browser service</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_BACKUP_BROWSER</term>
	<listitem><para>0x00020000  Backup browser server</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_MASTER_BROWSER</term>
	<listitem><para>0x00040000  Master browser server</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_DOMAIN_MASTER</term>
	<listitem><para>0x00080000  Domain Master Browser server</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_LOCAL_LIST_ONLY</term>
	<listitem><para>0x40000000  Enumerate only entries marked "local"</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_DOMAIN_ENUM</term>
	<listitem><para>0x80000000  Enumerate Domains. The pszServer and pszDomain parameters must be NULL.</para></listitem>
</varlistentry>

</variablelist>

<variablelist>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>500 - platform_id</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>pointer to name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>5 - major version</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>4 - minor version</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>type (SV_TYPE_... bit field)</para></listitem></varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>pointer to comment</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>sv101_name - unicode string of server name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>sv_101_comment  - unicode string of server comment.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>padding to get unicode string 4-byte aligned with start of the SMB header.</para></listitem>
</varlistentry>
</variablelist>

</sect3>
</sect2>
</sect1>

<sect1>
<title>MSRPC over Transact Named Pipe</title>

<para>For details on the SMB Transact Named Pipe, see cifs6.txt</para>

<sect2>
<title>MSRPC Pipes</title>

<para>
The MSRPC is conducted over an SMB Transact Pipe with a name of 
<filename moreinfo="none">\PIPE\</filename>.  You must first obtain a 16 bit file handle, by
sending a SMBopenX with the pipe name <filename moreinfo="none">\PIPE\srvsvc</filename> for
example.  You can then perform an SMB Trans,
and must carry out an SMBclose on the file handle once you are finished.
</para>

<para>
Trans Requests must be sent with two setup UINT16s, no UINT16 params (none
known about), and UINT8 data parameters sufficient to contain the MSRPC
header, and MSRPC data.  The first UINT16 setup parameter must be either
0x0026 to indicate an RPC, or 0x0001 to indicate Set Named Pipe Handle
state.  The second UINT16 parameter must be the file handle for the pipe,
obtained above.
</para>

<para>
The Data section for an API Command of 0x0026 (RPC pipe) in the Trans
Request is the RPC Header, followed by the RPC Data.  The Data section for
an API Command of 0x0001 (Set Named Pipe Handle state) is two bytes.  The
only value seen for these two bytes is 0x00 0x43.
</para>

<para>
MSRPC Responses are sent as response data inside standard SMB Trans
responses, with the MSRPC Header, MSRPC Data and MSRPC tail.
</para>

<para>
It is suspected that the Trans Requests will need to be at least 2-byte
aligned (probably 4-byte).  This is standard practice for SMBs.  It is also
independent of the observed 4-byte alignments with the start of the MSRPC
header, including the 4-byte alignment between the MSRPC header and the
MSRPC data.
</para>

<para>
First, an SMBtconX connection is made to the IPC$ share.  The connection
must be made using encrypted passwords, not clear-text.  Then, an SMBopenX
is made on the pipe.  Then, a Set Named Pipe Handle State must be sent,
after which the pipe is ready to accept API commands.  Lastly, and SMBclose
is sent.
</para>

<para>
To be resolved:
</para>

<para>
lkcl/01nov97 there appear to be two additional bytes after the null-terminated \PIPE\ name for the RPC pipe.  Values seen so far are
listed below:</para>

<para><programlisting format="linespecific">
        initial SMBopenX request:         RPC API command 0x26 params:
        "\\PIPE\\lsarpc"                  0x65 0x63; 0x72 0x70; 0x44 0x65;
        "\\PIPE\\srvsvc"                  0x73 0x76; 0x4E 0x00; 0x5C 0x43;
</programlisting></para>

</sect2>

<sect2>
<title>Header</title>

<para>[section to be rewritten, following receipt of work by Duncan Stansfield]</para>

<para>Interesting note: if you set packed data representation to 0x0100 0000
then all 4-byte and 2-byte word ordering is turned around!</para>

<para>The start of each of the NTLSA and NETLOGON named pipes begins with:</para>

<segmentedlist>
<segtitle>offset</segtitle><segtitle>Variable type</segtitle><segtitle>Variable data</segtitle>
<seglistitem><seg>00</seg><seg>UINT8</seg><seg>5 - RPC major version</seg></seglistitem>
<seglistitem><seg>01</seg><seg>UINT8</seg><seg>0 - RPC minor version</seg></seglistitem>
<seglistitem><seg>02</seg><seg>UINT8</seg><seg>2 - RPC response packet</seg></seglistitem>
<seglistitem><seg>03</seg><seg>UINT8</seg><seg>3 - (FirstFrag bit-wise or with LastFrag)</seg></seglistitem>
<seglistitem><seg>04</seg><seg>UINT32</seg><seg>0x1000 0000 - packed data representation</seg></seglistitem>
<seglistitem><seg>08</seg><seg>UINT16</seg><seg>fragment length - data size (bytes) inc header and tail.</seg></seglistitem>
<seglistitem><seg>0A</seg><seg>UINT16</seg><seg>0 - authentication length </seg></seglistitem>
<seglistitem><seg>0C</seg><seg>UINT32</seg><seg>call identifier. matches 12th UINT32 of incoming RPC data.</seg></seglistitem>
<seglistitem><seg>10</seg><seg>UINT32</seg><seg>allocation hint - data size (bytes) minus header and tail.</seg></seglistitem>
<seglistitem><seg>14</seg><seg>UINT16</seg><seg>0 - presentation context identifier</seg></seglistitem>
<seglistitem><seg>16</seg><seg>UINT8</seg><seg>0 - cancel count</seg></seglistitem>
<seglistitem><seg>17</seg><seg>UINT8</seg><seg>in replies: 0 - reserved; in requests: opnum - see #defines.</seg></seglistitem>
<seglistitem><seg>18</seg><seg>......</seg><seg>start of data (goes on for allocation_hint bytes)</seg></seglistitem>
</segmentedlist>

<sect3>
<title>RPC_Packet for request, response, bind and bind acknowledgement</title>

<variablelist>
<varlistentry>
	<term>UINT8 versionmaj</term>
<listitem><para>reply same as request (0x05)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8 versionmin</term>
<listitem><para>reply same as request (0x00)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8 type</term>
<listitem><para>one of the MSRPC_Type enums</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8 flags</term>
<listitem><para>reply same as request (0x00 for Bind, 0x03 for Request)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32 representation</term>
<listitem><para>reply same as request (0x00000010)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 fraglength</term>
<listitem><para>the length of the data section of the SMB trans packet</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 authlength</term>
	<listitem><para/></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32 callid</term>
<listitem><para>call identifier. (e.g. 0x00149594)</para></listitem></varlistentry>
<varlistentry>
	<term>* stub USE TvPacket</term>
<listitem><para>the remainder of the packet depending on the "type"</para></listitem></varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Interface identification</title>

<para>the interfaces are numbered. as yet I haven't seen more than one interface used on the same pipe name srvsvc</para>

<para><programlisting format="linespecific">
abstract (0x4B324FC8, 0x01D31670, 0x475A7812, 0x88E16EBF, 0x00000003)
transfer (0x8A885D04, 0x11C91CEB, 0x0008E89F, 0x6048102B, 0x00000002)
</programlisting></para>

</sect3>

<sect3>
<title>RPC_Iface RW</title>

<variablelist>
<varlistentry>
	<term>UINT8 byte[16]</term>
<listitem><para>16 bytes of number</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32 version</term>
<listitem><para>the interface number</para></listitem></varlistentry>
</variablelist>


</sect3>

<sect3>
<title>RPC_ReqBind RW</title>

<para>the remainder of the packet after the header if "type" was Bind in the response header, "type" should be BindAck</para>

<variablelist>
<varlistentry>
	<term>UINT16 maxtsize</term>
<listitem><para>maximum transmission fragment size (0x1630)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 maxrsize</term>
<listitem><para>max receive fragment size (0x1630)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32 assocgid</term>
<listitem><para>associated group id (0x0)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32 numelements</term>
<listitem><para>the number of elements (0x1)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 contextid</term>
<listitem><para>presentation context identifier (0x0)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8 numsyntaxes</term>
<listitem><para>the number of syntaxes (has always been 1?)(0x1)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8[]</term>
<listitem><para>4-byte alignment padding, against SMB header</para></listitem></varlistentry>
<varlistentry>
	<term>* abstractint USE RPC_Iface</term>
<listitem><para>num and vers. of interface client is using</para></listitem></varlistentry>
<varlistentry>
	<term>* transferint USE RPC_Iface</term>
	<listitem><para>num and vers. of interface to use for replies</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>RPC_Address RW</title>

<variablelist>
<varlistentry>
	<term>UINT16 length</term>
<listitem><para>length of the string including null terminator</para></listitem></varlistentry>
<varlistentry>
	<term>* port USE string</term>
<listitem><para>the string above in single byte, null terminated form</para></listitem></varlistentry>
</variablelist>

</sect3>

<sect3>
<title>RPC_ResBind RW</title>

<para>the response to place after the header in the reply packet</para>

<variablelist>
<varlistentry>
	<term>UINT16 maxtsize</term>
<listitem><para>same as request</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 maxrsize</term>
<listitem><para>same as request</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32 assocgid</term>
<listitem><para>zero</para></listitem></varlistentry>
<varlistentry>
	<term>* secondaddr USE RPC_Address</term>
<listitem><para>the address string, as described earlier</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8[]</term>
<listitem><para>4-byte alignment padding, against SMB header</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8 numresults</term>
<listitem><para>the number of results (0x01)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8[]</term>
<listitem><para>4-byte alignment padding, against SMB header</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 result</term>
<listitem><para>result (0x00 = accept)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 reason</term>
<listitem><para>reason (0x00 = no reason specified)</para></listitem></varlistentry>
<varlistentry>
	<term>* transfersyntax USE RPC_Iface</term>
<listitem><para>the transfer syntax from the request</para></listitem></varlistentry>
</variablelist>

</sect3>

<sect3>
<title>RPC_ReqNorm RW</title>

<para>the remainder of the packet after the header for every other other request</para>

<variablelist>
<varlistentry>
	<term>UINT32 allochint</term>
<listitem><para>the size of the stub data in bytes</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 prescontext</term>
<listitem><para>presentation context identifier (0x0)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 opnum</term>
<listitem><para>operation number (0x15)</para></listitem></varlistentry>
<varlistentry>
	<term>* stub USE TvPacket</term>
<listitem><para>a packet dependent on the pipe name (probably the interface) and the op number)</para></listitem></varlistentry>
</variablelist>

</sect3>

<sect3>
<title>RPC_ResNorm RW</title>

<variablelist>
<varlistentry>
	<term>UINT32 allochint</term>
<listitem><para># size of the stub data in bytes</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 prescontext</term>
<listitem><para># presentation context identifier (same as request)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8 cancelcount</term>
<listitem><para># cancel count? (0x0)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8 reserved</term>
<listitem><para># 0 - one byte padding</para></listitem></varlistentry>
<varlistentry>
	<term>* stub USE TvPacket</term>
<listitem><para># the remainder of the reply</para></listitem></varlistentry>
</variablelist>
</sect3>

</sect2>

<sect2>
<title>Tail</title>

<para>The end of each of the NTLSA and NETLOGON named pipes ends with:</para>

<variablelist>
<varlistentry>
	<term>......</term>
	<listitem><para>end of data</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>return code</para></listitem>
</varlistentry>
</variablelist>

</sect2>

<sect2>
<title>RPC Bind / Bind Ack</title>

<para>
RPC Binds are the process of associating an RPC pipe (e.g \PIPE\lsarpc)
with a "transfer syntax" (see RPC_Iface structure).  The purpose for doing
this is unknown.
</para>

<para><emphasis>Note: The RPC_ResBind SMB Transact request is sent with two uint16 setup parameters.  The first is 0x0026; the second is the file handle
	returned by the SMBopenX Transact response.</emphasis></para>

<para><emphasis>Note:	The RPC_ResBind members maxtsize, maxrsize and assocgid are the same in the response as the same members in the RPC_ReqBind.  The
	RPC_ResBind member transfersyntax is the same in the response as
	the</emphasis></para>

<para><emphasis>Note:	The RPC_ResBind response member secondaddr contains the name of what is presumed to be the service behind the RPC pipe.  The
	mapping identified so far is:</emphasis></para>

<variablelist>

<varlistentry>
	<term>initial SMBopenX request:</term>
	<listitem><para>RPC_ResBind response:</para></listitem>
</varlistentry>

<varlistentry>
	<term>"\\PIPE\\srvsvc"</term>
	<listitem><para>"\\PIPE\\ntsvcs"</para></listitem>
</varlistentry>
<varlistentry>
	<term>"\\PIPE\\samr"</term>
	<listitem><para>"\\PIPE\\lsass"</para></listitem>
</varlistentry>
<varlistentry>
	<term>"\\PIPE\\lsarpc"</term>
	<listitem><para>"\\PIPE\\lsass"</para></listitem>
</varlistentry>
<varlistentry>
	<term>"\\PIPE\\wkssvc"</term>
	<listitem><para>"\\PIPE\\wksvcs"</para></listitem>
</varlistentry>
<varlistentry>
	<term>"\\PIPE\\NETLOGON"</term>
	<listitem><para>"\\PIPE\\NETLOGON"</para></listitem>
</varlistentry>
</variablelist>

<para><emphasis>Note:	The RPC_Packet fraglength member in both the Bind Request and Bind Acknowledgment must contain the length of the entire RPC data, including the RPC_Packet header.</emphasis></para>

<para>Request:</para>

<simplelist type="vert">
<member>RPC_Packet</member>
<member>RPC_ReqBind</member>
</simplelist>

<para>Response:</para>
<simplelist type="vert">
<member>RPC_Packet</member>
<member>RPC_ResBind</member>
</simplelist>

</sect2>

<sect2>
<title>NTLSA Transact Named Pipe</title>

<para>The sequence of actions taken on this pipe are:</para>

<simplelist type="vert">
<member>Establish a connection to the IPC$ share (SMBtconX).  use encrypted passwords.</member>
<member>Open an RPC Pipe with the name "\\PIPE\\lsarpc".  Store the file handle.</member>
<member>Using the file handle, send a Set Named Pipe Handle state to 0x4300.</member>
<member>Send an LSA Open Policy request.  Store the Policy Handle.</member>
<member>Using the Policy Handle, send LSA Query Info Policy requests, etc.</member>
<member>Using the Policy Handle, send an LSA Close.</member>
<member>Close the IPC$ share.</member>
</simplelist>

<para>Defines for this pipe, identifying the query are:</para>
<variablelist>
<varlistentry>
	<term>LSA Open Policy:</term>
	<listitem><para>0x2c</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Query Info Policy:</term>
	<listitem><para>0x07</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Enumerate Trusted Domains:</term>
	<listitem><para>0x0d</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Open Secret:</term>
	<listitem><para>0xff</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Lookup SIDs:</term>
	<listitem><para>0xfe</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Lookup Names:</term>
	<listitem><para>0xfd</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Close:</term>
	<listitem><para>0x00</para></listitem>
</varlistentry>
</variablelist>

</sect2>

<sect2>
<title>LSA Open Policy</title>

<para><emphasis>Note:	The policy handle can be anything you like.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>server name - unicode string starting with two '\'s</para></listitem>
</varlistentry>
<varlistentry>
	<term>OBJ_ATTR</term>
	<listitem><para>object attributes</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>1 - desired access</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>

<varlistentry>
	<term>POL_HND</term>
	<listitem><para>LSA policy handle</para></listitem>
</varlistentry>

<varlistentry>
	<term>return</term>
	<listitem><para>0 - indicates success</para></listitem>
</varlistentry>

</variablelist>

</sect3>

</sect2>

<sect2>
<title>LSA Query Info Policy</title>

<para><emphasis>Note:	The info class in response must be the same as that in the request.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>POL_HND</term>
<listitem><para>LSA policy handle</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16</term>
<listitem><para>info class (also a policy handle?)</para></listitem></varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>info class (same as info class in request).</para></listitem>
</varlistentry>

</variablelist>

<para><programlisting format="linespecific">
switch (info class)
case 3:
case 5:
{
DOM_INFO domain info, levels 3 and 5 (are the same).
}

return    0 - indicates success
</programlisting></para>

</sect3>

</sect2>

<sect2>
<title>LSA Enumerate Trusted Domains</title>

<sect3>
<title>Request</title>

<para>no extra data</para>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - enumeration context</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - entries read</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - trust information</para></listitem>
</varlistentry>
<varlistentry>
	<term>return</term>
	<listitem><para>0x8000 001a - "no trusted domains" success code</para></listitem>
</varlistentry>
</variablelist>

</sect3>
</sect2>

<sect2>
<title>LSA Open Secret</title>

<sect3>
<title>Request</title>

<para>no extra data</para>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - undocumented</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - undocumented</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - undocumented</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - undocumented</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - undocumented</para></listitem>
</varlistentry>
</variablelist>

<para>return    0x0C00 0034 - "no such secret" success code</para>

</sect3>

</sect2>

<sect2>
<title>LSA Close</title>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>POL_HND</term>
	<listitem><para>policy handle to be closed</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>POL_HND</term>
<listitem><para>0s - closed policy handle (all zeros)</para></listitem></varlistentry>
</variablelist>

<para>return    0 - indicates success</para>

</sect3>
</sect2>

<sect2>
<title>LSA Lookup SIDS</title>

<para><emphasis>Note:	num_entries in response must be same as num_entries in request.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>POL_HND</term>
	<listitem><para>LSA policy handle</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>num_entries</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented domain SID buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented domain name buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*[num_entries] undocumented domain SID pointers to be looked up.
</term>
<listitem><para>DOM_SID[num_entries] domain SIDs to be looked up.</para></listitem></varlistentry>
<varlistentry>
	<term>char[16]</term>
	<listitem><para>completely undocumented 16 bytes.</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>DOM_REF</term>
<listitem><para>domain reference response</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>num_entries (listed above)</para></listitem></varlistentry>
<varlistentry>
	<term>VOID*</term>
<listitem><para>undocumented buffer pointer</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>num_entries (listed above)</para></listitem></varlistentry>
<varlistentry>
	<term>DOM_SID2[num_entries]</term>
<listitem><para>domain SIDs (from Request, listed above).</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>num_entries (listed above)</para></listitem></varlistentry>
</variablelist>

<para>return                0 - indicates success</para>

</sect3>

</sect2>

<sect2>
<title>LSA Lookup Names</title>

<para><emphasis>Note:	num_entries in response must be same as num_entries in request.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>POL_HND</term>
	<listitem><para>LSA policy handle</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>num_entries</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>num_entries</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented domain SID buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented domain name buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>NAME[num_entries]</term>
	<listitem><para>names to be looked up.</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[]</term>
	<listitem><para>undocumented bytes - falsely translated SID structure?</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>DOM_REF</term>
<listitem><para>domain reference response</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>num_entries (listed above)</para></listitem></varlistentry>
<varlistentry>
	<term>VOID*</term>
<listitem><para>undocumented buffer pointer</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>num_entries (listed above)</para></listitem></varlistentry>
<varlistentry>
	<term>DOM_RID[num_entries]</term>
<listitem><para>domain SIDs (from Request, listed above).</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>num_entries (listed above)</para></listitem></varlistentry>
</variablelist>

<para>return                0 - indicates success</para>

</sect3>
</sect2>
</sect1>

<sect1>
<title>NETLOGON rpc Transact Named Pipe</title>

<para>The sequence of actions taken on this pipe are:</para>

<simplelist type="vert">
<member>tablish a connection to the IPC$ share (SMBtconX).  use encrypted passwords.</member>
<member>en an RPC Pipe with the name "\\PIPE\\NETLOGON".  Store the file handle.</member>
<member>ing the file handle, send a Set Named Pipe Handle state to 0x4300.</member>
<member>eate Client Challenge. Send LSA Request Challenge.  Store Server Challenge.</member>
<member>lculate Session Key.  Send an LSA Auth 2 Challenge.  Store Auth2 Challenge.</member>
<member>lc/Verify Client Creds.  Send LSA Srv PW Set.  Calc/Verify Server Creds.</member>
<member>lc/Verify Client Creds.  Send LSA SAM Logon .  Calc/Verify Server Creds.</member>
<member>lc/Verify Client Creds.  Send LSA SAM Logoff.  Calc/Verify Server Creds.</member>
<member>ose the IPC$ share.</member>
</simplelist>

<para>Defines for this pipe, identifying the query are</para>

<variablelist>
<varlistentry>
	<term>LSA Request Challenge:</term>
	<listitem><para>0x04</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Server Password Set:</term>
	<listitem><para>0x06</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA SAM Logon:</term>
	<listitem><para>0x02</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA SAM Logoff:</term>
	<listitem><para>0x03</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Auth 2:</term>
	<listitem><para>0x0f</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Logon Control:</term>
	<listitem><para>0x0e</para></listitem>
</varlistentry>
</variablelist>

<sect2>
<title>LSA Request Challenge</title>

<para><emphasis>Note:	logon server name starts with two '\' characters and is upper case.</emphasis></para>

<para><emphasis>Note:	logon client is the machine, not the user.</emphasis></para>

<para><emphasis>Note:	the initial LanManager password hash, against which the challenge is issued, is the machine name itself (lower case).  there will becalls issued (LSA Server Password Set) which will change this, later. refusing these calls allows you to always deal with the same password (i.e the LM# of the machine name in lower case).</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon server unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon client unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[8]</term>
	<listitem><para>client challenge</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>char[8]</term>
	<listitem><para>server challenge</para></listitem>
</varlistentry>
</variablelist>

<para>return    0 - indicates success</para>

</sect3>

</sect2>

<sect2>
<title>LSA Authenticate 2</title>

<para><emphasis>Note:	in between request and response, calculate the client credentials, and check them against the client-calculated credentials (this process uses the previously received client credentials).</emphasis></para>

<para><emphasis>Note:	neg_flags in the response is the same as that in the request.</emphasis></para>

<para><emphasis>Note:	you must take a copy of the client-calculated credentials received 	here, because they will be used in subsequent authentication packets.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>LOG_INFO</term>
	<listitem><para>client identification info</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[8]</term>
	<listitem><para>client-calculated credentials</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8[]</term>
<listitem><para>padding to 4-byte align with start of SMB header.</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>neg_flags - negotiated flags (usual value is 0x0000 01ff)</para></listitem></varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>char[8]</term>
	<listitem><para>server credentials.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>neg_flags - same as neg_flags in request.</para></listitem>
</varlistentry>
</variablelist>

<para>return    0 - indicates success.  failure value unknown.</para>

</sect3>

</sect2>

<sect2>
<title>LSA Server Password Set</title>

<para><emphasis>Note: the new password is suspected to be a DES encryption using the old password to generate the key.</emphasis></para>

<para><emphasis>Note: in between request and response, calculate the client credentials, and check them against the client-calculated credentials (this process uses the previously received client credentials).</emphasis></para>

<para><emphasis>Note: the server credentials are constructed from the client-calculated credentials and the client time + 1 second.</emphasis></para>

<para><emphasis>Note: you must take a copy of the client-calculated credentials received here, because they will be used in subsequent authentication packets.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>CLNT_INFO</term>
	<listitem><para>client identification/authentication info</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[]</term>
	<listitem><para>new password - undocumented.</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>CREDS</term>
	<listitem><para>server credentials.  server time stamp appears to be ignored.</para></listitem>
</varlistentry>
</variablelist>

<para>return    0 - indicates success; 0xC000 006a indicates failure</para>

</sect3>
</sect2>

<sect2>
<title>LSA SAM Logon</title>

<para><emphasis>
Note:	valid_user is True iff the username and password hash are valid for
	the requested domain.
</emphasis></para>

<sect3>
<title>Request</title>
<variablelist>
<varlistentry>
	<term>SAM_INFO</term>
	<listitem><para>sam_id structure</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>CREDS</term>
	<listitem><para>server credentials.  server time stamp appears to be ignored.</para></listitem>
</varlistentry>
</variablelist>

<para><programlisting format="linespecific">
if (valid_user)
{
	UINT16      3 - switch value indicating USER_INFO structure.
    VOID*     non-zero - pointer to USER_INFO structure
    USER_INFO user logon information

    UINT32    1 - Authoritative response; 0 - Non-Auth?

    return    0 - indicates success
}
else
{
	UINT16    0 - switch value.  value to indicate no user presumed.
    VOID*     0x0000 0000 - indicates no USER_INFO structure.

    UINT32    1 - Authoritative response; 0 - Non-Auth?

    return    0xC000 0064 - NT_STATUS_NO_SUCH_USER.
}
</programlisting></para>

</sect3>

</sect2>

<sect2>
<title>LSA SAM Logoff</title>

<para><emphasis>
Note:	presumably, the SAM_INFO structure is validated, and a (currently
	undocumented) error code returned if the Logoff is invalid.
</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>SAM_INFO</term>
	<listitem><para>sam_id structure</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>CREDS</term>
	<listitem><para>server credentials.  server time stamp appears to be ignored.</para></listitem>
</varlistentry>
</variablelist>

<para>return      0 - indicates success.  undocumented failure indication.</para>

</sect3>
</sect2>
</sect1>

<sect1>
<title>\\MAILSLOT\NET\NTLOGON</title>

<para><emphasis>
Note:	mailslots will contain a response mailslot, to which the response
	should be sent.  the target NetBIOS name is REQUEST_NAME&lt;20&gt;, where
	REQUEST_NAME is the name of the machine that sent the request.
</emphasis></para>

<sect2>
<title>Query for PDC</title>

<para><emphasis>Note:	NTversion, LMNTtoken, LM20token in response are the same as those 	given in the request.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>0x0007 - Query for PDC</para></listitem>
</varlistentry>
<varlistentry>
	<term>STR</term>
	<listitem><para>machine name</para></listitem>
</varlistentry>
<varlistentry>
	<term>STR</term>
	<listitem><para>response mailslot</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>padding to 2-byte align with start of mailslot.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>machine name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>NTversion</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>LMNTtoken</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>LM20token</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>UINT16</term>
<listitem><para>0x000A - Respose to Query for PDC</para></listitem></varlistentry>
<varlistentry>
	<term>STR</term>
<listitem><para>machine name (in uppercase)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>padding to 2-byte align with start of mailslot.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>machine name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
<listitem><para>domain name</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>NTversion (same as received in request)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16</term>
<listitem><para>LMNTtoken (same as received in request)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16</term>
<listitem><para>LM20token (same as received in request)</para></listitem></varlistentry>
</variablelist>

</sect3>
</sect2>

<sect2>
<title>SAM Logon</title>

<para><emphasis>Note: machine name in response is preceded by two '\' characters.</emphasis></para>

<para><emphasis>Note:	NTversion, LMNTtoken, LM20token in response are the same as those given in the request.</emphasis></para>

<para><emphasis>Note:	user name in the response is presumably the same as that in the request.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>0x0012 - SAM Logon</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>request count</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>machine name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>user name</para></listitem>
</varlistentry>
<varlistentry>
	<term>STR</term>
	<listitem><para>response mailslot</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>alloweable account</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>domain SID size</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[sid_size]</term>
	<listitem><para>domain SID, of sid_size bytes.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>???? padding to 4? 2? -byte align with start of mailslot.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>NTversion</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>LMNTtoken</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>LM20token</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>0x0013 - Response to SAM Logon</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>machine name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>user name - workstation trust account</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>domain name </para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>NTversion</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>LMNTtoken</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>LM20token</para></listitem>
</varlistentry>
</variablelist>

</sect3>
</sect2>
</sect1>

<sect1>
<title>SRVSVC Transact Named Pipe</title>

<para>Defines for this pipe, identifying the query are:</para>

<variablelist>
<varlistentry>
	<term>Net Share Enum</term>
	<listitem><para>0x0f</para></listitem>
</varlistentry>
<varlistentry>
	<term>Net Server Get Info</term>
	<listitem><para>0x15</para></listitem>
</varlistentry>

</variablelist>

<sect2>
<title>Net Share Enum</title>

<para><emphasis>Note:	share level and switch value in the response are presumably the same as those in the request.</emphasis></para>

<para><emphasis>Note:	cifsrap2.txt (section 5) may be of limited assistance here.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>VOID*</term>
<listitem><para>pointer (to server name?)</para></listitem></varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>server name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>padding to get unicode string 4-byte aligned with the start of the SMB header.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>share level</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>switch value</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>pointer to SHARE_INFO_1_CTR</para></listitem>
</varlistentry>
<varlistentry>
	<term>SHARE_INFO_1_CTR</term>
	<listitem><para>share info with 0 entries</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>preferred maximum length (0xffff ffff)</para></listitem></varlistentry>
</variablelist>
</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>share level</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>switch value</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
<listitem><para>pointer to SHARE_INFO_1_CTR</para></listitem></varlistentry>
<varlistentry>
	<term>SHARE_INFO_1_CTR</term>
<listitem><para>share info (only added if share info ptr is non-zero)</para></listitem></varlistentry>
</variablelist>

<para>return            0 - indicates success</para>

</sect3>
</sect2>

<sect2>
<title>Net Server Get Info</title>

<para><emphasis>Note:	level is the same value as in the request.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>server name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>switch level</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>switch level</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>pointer to SERVER_INFO_101</para></listitem>
</varlistentry>
<varlistentry>
	<term>SERVER_INFO_101</term>
<listitem><para>server info (only added if server info ptr is non-zero)</para></listitem></varlistentry>
</variablelist>

<para>return            0 - indicates success</para>

</sect3>
</sect2>
</sect1>

<sect1>
<title>Cryptographic side of NT Domain Authentication</title>

<sect2>
<title>Definitions</title>

<variablelist>
<varlistentry>
<term>Add(A1,A2)</term>
<listitem><para>Intel byte ordered addition of corresponding 4 byte words in arrays A1 and A2</para></listitem>
</varlistentry>

<varlistentry>
<term>E(K,D)</term>
<listitem><para>DES ECB encryption of 8 byte data D using 7 byte key K</para></listitem>
</varlistentry>

<varlistentry>
<term>lmowf()</term>
<listitem><para>Lan man hash</para></listitem>
</varlistentry>

<varlistentry>
<term>ntowf()</term>
<listitem><para>NT hash</para></listitem>
</varlistentry>

<varlistentry>
<term>PW</term>
<listitem><para>md4(machine_password) == md4(lsadump $machine.acc) ==
pwdump(machine$) (initially) == md4(lmowf(unicode(machine)))
</para></listitem>
</varlistentry>

<varlistentry>
<term>ARC4(K,Lk,D,Ld)</term>
<listitem><para>ARC4 encryption of data D of length Ld with key K of length Lk</para></listitem>
</varlistentry>

<varlistentry>
<term>v[m..n(,l)]</term>
<listitem><para>subset of v from bytes m to n, optionally padded with zeroes to length l</para></listitem>
</varlistentry>

<varlistentry>
<term>Cred(K,D)</term>
<listitem><para>E(K[7..7,7],E(K[0..6],D)) computes a credential</para></listitem>
</varlistentry>

<varlistentry>
<term>Time()</term>
<listitem><para>4 byte current time</para></listitem>
</varlistentry>

<varlistentry>
<term>Cc,Cs</term>
<listitem><para>8 byte client and server challenges Rc,Rs: 8 byte client and server credentials</para></listitem>
</varlistentry>

</variablelist>

</sect2>

<sect2>
<title>Protocol</title>

<programlisting format="linespecific">
C-&gt;S ReqChal,Cc
S-&gt;C Cs
</programlisting>

<programlisting format="linespecific">
C &amp; S compute session key Ks = E(PW[9..15],E(PW[0..6],Add(Cc,Cs)))
</programlisting>

<programlisting format="linespecific">
C: Rc = Cred(Ks,Cc)
C-&gt;S Authenticate,Rc
S: Rs = Cred(Ks,Cs), assert(Rc == Cred(Ks,Cc))
S-&gt;C Rs
C: assert(Rs == Cred(Ks,Cs))
</programlisting>

<para>
On joining the domain the client will optionally attempt to change its
password and the domain controller may refuse to update it depending
on registry settings. This will also occur weekly afterwards.
</para>

<programlisting format="linespecific">
C: Tc = Time(), Rc' = Cred(Ks,Rc+Tc)
C-&gt;S ServerPasswordSet,Rc',Tc,arc4(Ks[0..7,16],lmowf(randompassword())
C: Rc = Cred(Ks,Rc+Tc+1)
S: assert(Rc' == Cred(Ks,Rc+Tc)), Ts = Time()
S: Rs' = Cred(Ks,Rs+Tc+1)
S-&gt;C Rs',Ts
C: assert(Rs' == Cred(Ks,Rs+Tc+1))
S: Rs = Rs'
</programlisting>

<para>
User: U with password P wishes to login to the domain (incidental data
such as workstation and domain omitted)
</para>

<programlisting format="linespecific">
C: Tc = Time(), Rc' = Cred(Ks,Rc+Tc)
C-&gt;S NetLogonSamLogon,Rc',Tc,U,arc4(Ks[0..7,16],16,ntowf(P),16), arc4(Ks[0..7,16],16,lmowf(P),16)
S: assert(Rc' == Cred(Ks,Rc+Tc)) assert(passwords match those in SAM)
S: Ts = Time()
</programlisting>

<programlisting format="linespecific">
S-&gt;C Cred(Ks,Cred(Ks,Rc+Tc+1)),userinfo(logon script,UID,SIDs,etc)
C: assert(Rs == Cred(Ks,Cred(Rc+Tc+1))
C: Rc = Cred(Ks,Rc+Tc+1)
</programlisting>

</sect2>

<sect2>
<title>Comments</title>

<para>
On first joining the domain the session key could be computed by
anyone listening in on the network as the machine password has a well
known value. Until the machine is rebooted it will use this session
key to encrypt NT and LM one way functions of passwords which are
password equivalents. Any user who logs in before the machine has been
rebooted a second time will have their password equivalent exposed. Of
course the new machine password is exposed at this time anyway.
</para>

<para>
None of the returned user info such as logon script, profile path and
SIDs *appear* to be protected by anything other than the TCP checksum.
</para>

<para>
The server time stamps appear to be ignored.
</para>

<para>
The client sends a ReturnAuthenticator in the SamLogon request which I
can't find a use for.  However its time is used as the timestamp
returned by the server.
</para>

<para>
The password OWFs should NOT be sent over the network reversibly
encrypted. They should be sent using ARC4(Ks,md4(owf)) with the server
computing the same function using the owf values in the SAM.
</para>

</sect2>
</sect1>

<sect1>
<title>SIDs and RIDs</title>

<para>
SIDs and RIDs are well documented elsewhere.
</para>

<para>
A SID is an NT Security ID (see DOM_SID structure).  They are of the form:
</para>

<simplelist type="vert">
<member>revision-NN-SubAuth1-SubAuth2-SubAuth3... </member>
<member>revision-0xNNNNNNNNNNNN-SubAuth1-SubAuth2-SubAuth3...</member>
</simplelist>

<para>
currently, the SID revision is 1.
The Sub-Authorities are known as Relative IDs (RIDs).
</para>

<sect2>
<title>Well-known SIDs</title>

<sect3>
<title>Universal well-known SIDs</title>

<variablelist>
<varlistentry>
	<term>Null SID</term>
	<listitem><para>S-1-0-0</para></listitem>
</varlistentry>
<varlistentry>
	<term>World</term>
	<listitem><para>S-1-1-0</para></listitem>
</varlistentry>
<varlistentry>
	<term>Local</term>
	<listitem><para>S-1-2-0</para></listitem>
</varlistentry>
<varlistentry>
	<term>Creator Owner ID</term>
	<listitem><para>S-1-3-0</para></listitem>
</varlistentry>
<varlistentry>
	<term>Creator Group ID</term>
	<listitem><para>S-1-3-1</para></listitem>
</varlistentry>
<varlistentry>
	<term>Creator Owner Server ID</term>
	<listitem><para>S-1-3-2</para></listitem>
</varlistentry>
<varlistentry>
	<term>Creator Group Server ID</term>
	<listitem><para>S-1-3-3</para></listitem>
</varlistentry>
<varlistentry>
	<term>(Non-unique IDs)</term>
	<listitem><para>S-1-4</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>NT well-known SIDs</title>

<variablelist>
<varlistentry>
	<term>NT Authority</term>
	<listitem><para>S-1-5</para></listitem>
</varlistentry>
<varlistentry>
	<term>Dialup</term>
	<listitem><para>S-1-5-1</para></listitem>
</varlistentry>
<varlistentry>
	<term>Network</term>
	<listitem><para>S-1-5-2</para></listitem>
</varlistentry>
<varlistentry>
	<term>Batch</term>
	<listitem><para>S-1-5-3</para></listitem>
</varlistentry>
<varlistentry>
	<term>Interactive</term>
	<listitem><para>S-1-5-4</para></listitem>
</varlistentry>
<varlistentry>
	<term>Service</term>
<listitem><para>S-1-5-6</para></listitem></varlistentry>
<varlistentry>
	<term>AnonymousLogon(aka null logon session)</term>
	<listitem><para>S-1-5-7</para></listitem>
</varlistentry>
<varlistentry>
	<term>Proxy</term>
<listitem><para>S-1-5-8</para></listitem></varlistentry>
<varlistentry>
	<term>ServerLogon(aka domain controller account)</term>
	<listitem><para>S-1-5-8</para></listitem>
</varlistentry>
<varlistentry>
	<term>(Logon IDs)</term>
	<listitem><para>S-1-5-5-X-Y</para></listitem>
</varlistentry>
<varlistentry>
	<term>(NT non-unique IDs)</term>
	<listitem><para>S-1-5-0x15-...</para></listitem>
</varlistentry>
<varlistentry>
	<term>(Built-in domain)</term>
	<listitem><para>s-1-5-0x20</para></listitem>
</varlistentry>
</variablelist>

</sect3>
</sect2>

<sect2>
<title>Well-known RIDS</title>

<para>
A RID is a sub-authority value, as part of either a SID, or in the case
of Group RIDs, part of the DOM_GID structure, in the USER_INFO_1
structure, in the LSA SAM Logon response.
</para>

<sect3>
<title>Well-known RID users</title>

<segmentedlist>
<segtitle>Groupname</segtitle>
<segtitle>????</segtitle>
<segtitle>RID</segtitle>
<seglistitem><seg>DOMAIN_USER_RID_ADMIN</seg><seg>0x0000</seg><seg>01F4</seg></seglistitem>
<seglistitem><seg>DOMAIN_USER_RID_GUEST</seg><seg>0x0000</seg><seg>01F5</seg></seglistitem>
</segmentedlist>

</sect3>

<sect3>
<title>Well-known RID groups</title>

<segmentedlist>
<segtitle>Groupname</segtitle>
<segtitle>????</segtitle>
<segtitle>RID</segtitle>
<seglistitem><seg>	DOMAIN_GROUP_RID_ADMINS</seg><seg>0x0000</seg><seg>0200</seg></seglistitem>
<seglistitem><seg>	DOMAIN_GROUP_RID_USERS</seg><seg>0x0000</seg><seg>0201</seg></seglistitem>
<seglistitem><seg>	DOMAIN_GROUP_RID_GUESTS</seg><seg>0x0000</seg><seg>0202</seg></seglistitem>
</segmentedlist>

</sect3>

<sect3>
<title>Well-known RID aliases</title>

<segmentedlist>
<segtitle>Groupname</segtitle>
<segtitle>????</segtitle>
<segtitle>RID</segtitle>
<seglistitem><seg>	DOMAIN_ALIAS_RID_ADMINS</seg><seg>0x0000</seg><seg>0220</seg></seglistitem>
<seglistitem><seg>	DOMAIN_ALIAS_RID_USERS</seg><seg>0x0000</seg><seg>0221</seg></seglistitem>
<seglistitem><seg>	DOMAIN_ALIAS_RID_GUESTS</seg><seg>0x0000</seg><seg>0222</seg></seglistitem>
<seglistitem><seg>	DOMAIN_ALIAS_RID_POWER_USERS</seg><seg>0x0000</seg><seg>0223</seg></seglistitem>
<seglistitem><seg>	DOMAIN_ALIAS_RID_ACCOUNT_OPS</seg><seg>0x0000</seg><seg>0224</seg></seglistitem>
<seglistitem><seg>	DOMAIN_ALIAS_RID_SYSTEM_OPS</seg><seg>0x0000</seg><seg>0225</seg></seglistitem>
<seglistitem><seg>	DOMAIN_ALIAS_RID_PRINT_OPS</seg><seg>0x0000</seg><seg>0226</seg></seglistitem>
<seglistitem><seg>	DOMAIN_ALIAS_RID_BACKUP_OPS</seg><seg>0x0000</seg><seg>0227</seg></seglistitem>
<seglistitem><seg>	DOMAIN_ALIAS_RID_REPLICATOR</seg><seg>0x0000</seg><seg>0228</seg></seglistitem>
</segmentedlist>

</sect3>
</sect2>
</sect1>
</chapter>

</part>

<part>
	<title>Samba Basics</title>

	<chapter id="architecture">
<chapterinfo>
	<author>
		<firstname>Dan</firstname><surname>Shearer</surname>
	</author>
	<pubdate> November 1997</pubdate>
</chapterinfo>

<title>Samba Architecture</title>

<sect1>
<title>Introduction</title>

<para>
This document gives a general overview of how Samba works
internally. The Samba Team has tried to come up with a model which is
the best possible compromise between elegance, portability, security
and the constraints imposed by the very messy SMB and CIFS
protocol. 
</para>

<para>
It also tries to answer some of the frequently asked questions such as:
</para>

<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><para>
	Is Samba secure when running on Unix? The xyz platform?
	What about the root priveliges issue?
</para></listitem>

<listitem><para>Pros and cons of multithreading in various parts of Samba</para></listitem>

<listitem><para>Why not have a separate process for name resolution, WINS, and browsing?</para></listitem>

</orderedlist>

</sect1>

<sect1>
<title>Multithreading and Samba</title>

<para>
People sometimes tout threads as a uniformly good thing. They are very
nice in their place but are quite inappropriate for smbd. nmbd is
another matter, and multi-threading it would be very nice. 
</para>

<para>
The short version is that smbd is not multithreaded, and alternative
servers that take this approach under Unix (such as Syntax, at the
time of writing) suffer tremendous performance penalties and are less
robust. nmbd is not threaded either, but this is because it is not
possible to do it while keeping code consistent and portable across 35
or more platforms. (This drawback also applies to threading smbd.)
</para>

<para>
The longer versions is that there are very good reasons for not making
smbd multi-threaded.  Multi-threading would actually make Samba much
slower, less scalable, less portable and much less robust. The fact
that we use a separate process for each connection is one of Samba's
biggest advantages.
</para>

</sect1>

<sect1>
<title>Threading smbd</title>

<para>
A few problems that would arise from a threaded smbd are:
</para>

<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><para>
	It's not only to create threads instead of processes, but you
	must care about all variables if they have to be thread specific
	(currently they would be global).
</para></listitem>

<listitem><para>
	if one thread dies (eg. a seg fault) then all threads die. We can
	immediately throw robustness out the window.
</para></listitem>

<listitem><para>
	many of the system calls we make are blocking. Non-blocking
	equivalents of many calls are either not available or are awkward (and
	slow) to use. So while we block in one thread all clients are
	waiting. Imagine if one share is a slow NFS filesystem and the others 
	are fast, we will end up slowing all clients to the speed of NFS.
</para></listitem>

<listitem><para>
	you can't run as a different uid in different threads. This means
	we would have to switch uid/gid on _every_ SMB packet. It would be
	horrendously slow.
</para></listitem>

<listitem><para>
	the per process file descriptor limit would mean that we could only
	support a limited number of clients.
</para></listitem>

<listitem><para>
	we couldn't use the system locking calls as the locking context of
	fcntl() is a process, not a thread.
</para></listitem>

</orderedlist>

</sect1>

<sect1>
<title>Threading nmbd</title>

<para>
This would be ideal, but gets sunk by portability requirements.
</para>

<para>
Andrew tried to write a test threads library for nmbd that used only
ansi-C constructs (using setjmp and longjmp). Unfortunately some OSes
defeat this by restricting longjmp to calling addresses that are
shallower than the current address on the stack (apparently AIX does
this). This makes a truly portable threads library impossible. So to
support all our current platforms we would have to code nmbd both with
and without threads, and as the real aim of threads is to make the
code clearer we would not have gained anything. (it is a myth that
threads make things faster. threading is like recursion, it can make
things clear but the same thing can always be done faster by some
other method)
</para>

<para>
Chris tried to spec out a general design that would abstract threading
vs separate processes (vs other methods?) and make them accessible
through some general API. This doesn't work because of the data
sharing requirements of the protocol (packets in the future depending
on packets now, etc.) At least, the code would work but would be very
clumsy, and besides the fork() type model would never work on Unix. (Is there an OS that it would work on, for nmbd?)
</para>

<para>
A fork() is cheap, but not nearly cheap enough to do on every UDP
packet that arrives. Having a pool of processes is possible but is
nasty to program cleanly due to the enormous amount of shared data (in
complex structures) between the processes. We can't rely on each
platform having a shared memory system.
</para>

</sect1>

<sect1>
<title>nbmd Design</title>

<para>
Originally Andrew used recursion to simulate a multi-threaded
environment, which use the stack enormously and made for really
confusing debugging sessions. Luke Leighton rewrote it to use a
queuing system that keeps state information on each packet.  The
first version used a single structure which was used by all the
pending states.  As the initialisation of this structure was
done by adding arguments, as the functionality developed, it got
pretty messy.  So, it was replaced with a higher-order function
and a pointer to a user-defined memory block.  This suddenly
made things much simpler: large numbers of functions could be
made static, and modularised.  This is the same principle as used
in NT's kernel, and achieves the same effect as threads, but in
a single process.
</para>

<para>
Then Jeremy rewrote nmbd. The packet data in nmbd isn't what's on the
wire. It's a nice format that is very amenable to processing but still
keeps the idea of a distinct packet. See "struct packet_struct" in
nameserv.h.  It has all the detail but none of the on-the-wire
mess. This makes it ideal for using in disk or memory-based databases
for browsing and WINS support. 
</para>

</sect1>
</chapter>
	<chapter id="debug">
<chapterinfo>
	<author>
		<firstname>Chris</firstname><surname>Hertel</surname>
	</author>
	<pubdate>July 1998</pubdate>
</chapterinfo>

<title>The samba DEBUG system</title>

<sect1>
<title>New Output Syntax</title>

<para>
   The syntax of a debugging log file is represented as:
</para>

<para><programlisting format="linespecific">
  &gt;debugfile&lt; :== { &gt;debugmsg&lt; }

  &gt;debugmsg&lt;  :== &gt;debughdr&lt; '\n' &gt;debugtext&lt;

  &gt;debughdr&lt;  :== '[' TIME ',' LEVEL ']' FILE ':' [FUNCTION] '(' LINE ')'

  &gt;debugtext&lt; :== { &gt;debugline&lt; }

  &gt;debugline&lt; :== TEXT '\n'
</programlisting></para>

<para>
TEXT is a string of characters excluding the newline character.
</para>

<para>
LEVEL is the DEBUG level of the message (an integer in the range
		0..10).
</para>

<para>
TIME is a timestamp.
</para>

<para>
FILE is the name of the file from which the debug message was
generated.
</para>

<para>
FUNCTION is the function from which the debug message was generated.
</para>

<para>
LINE is the line number of the debug statement that generated the
message.
</para>

<para>Basically, what that all means is:</para>
<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><para>
A debugging log file is made up of debug messages.
</para></listitem>
<listitem><para>
Each debug message is made up of a header and text. The header is
separated from the text by a newline.
</para></listitem>
<listitem><para>
The header begins with the timestamp and debug level of the
message enclosed in brackets. The filename, function, and line
number at which the message was generated follow. The filename is
terminated by a colon, and the function name is terminated by the
parenthesis which contain the line number. Depending upon the
compiler, the function name may be missing (it is generated by the
__FUNCTION__ macro, which is not universally implemented, dangit).
</para></listitem>
<listitem><para>
The message text is made up of zero or more lines, each terminated
by a newline.
</para></listitem>
</orderedlist>

<para>Here's some example output:</para>

<para><programlisting format="linespecific">
    [1998/08/03 12:55:25, 1] nmbd.c:(659)
      Netbios nameserver version 1.9.19-prealpha started.
      Copyright Andrew Tridgell 1994-1997
    [1998/08/03 12:55:25, 3] loadparm.c:(763)
      Initializing global parameters
</programlisting></para>

<para>
Note that in the above example the function names are not listed on
the header line. That's because the example above was generated on an
SGI Indy, and the SGI compiler doesn't support the __FUNCTION__ macro.
</para>

</sect1>

<sect1>
<title>The DEBUG() Macro</title>

<para>
Use of the DEBUG() macro is unchanged. DEBUG() takes two parameters.
The first is the message level, the second is the body of a function
call to the Debug1() function.
</para>

<para>That's confusing.</para>

<para>Here's an example which may help a bit. If you would write</para>

<para><programlisting format="linespecific">
printf( "This is a %s message.\n", "debug" );
</programlisting></para>

<para>
to send the output to stdout, then you would write
</para>

<para><programlisting format="linespecific">
DEBUG( 0, ( "This is a %s message.\n", "debug" ) );
</programlisting></para>

<para>
to send the output to the debug file.  All of the normal printf()
formatting escapes work.
</para>

<para>
Note that in the above example the DEBUG message level is set to 0.
Messages at level 0 always print.  Basically, if the message level is
less than or equal to the global value DEBUGLEVEL, then the DEBUG
statement is processed.
</para>

<para>
The output of the above example would be something like:
</para>

<para><programlisting format="linespecific">
    [1998/07/30 16:00:51, 0] file.c:function(128)
      This is a debug message.
</programlisting></para>

<para>
Each call to DEBUG() creates a new header *unless* the output produced
by the previous call to DEBUG() did not end with a '\n'. Output to the
debug file is passed through a formatting buffer which is flushed
every time a newline is encountered. If the buffer is not empty when
DEBUG() is called, the new input is simply appended.
</para>

<para>
...but that's really just a Kludge. It was put in place because
DEBUG() has been used to write partial lines. Here's a simple (dumb)
example of the kind of thing I'm talking about:
</para>

<para><programlisting format="linespecific">
    DEBUG( 0, ("The test returned " ) );
    if( test() )
      DEBUG(0, ("True") );
    else
      DEBUG(0, ("False") );
    DEBUG(0, (".\n") );
</programlisting></para>

<para>
Without the format buffer, the output (assuming test() returned true)
would look like this:
</para>

<para><programlisting format="linespecific">
    [1998/07/30 16:00:51, 0] file.c:function(256)
      The test returned
    [1998/07/30 16:00:51, 0] file.c:function(258)
      True
    [1998/07/30 16:00:51, 0] file.c:function(261)
      .
</programlisting></para>

<para>Which isn't much use. The format buffer kludge fixes this problem.
</para>

</sect1>

<sect1>
<title>The DEBUGADD() Macro</title>

<para>
In addition to the kludgey solution to the broken line problem
described above, there is a clean solution. The DEBUGADD() macro never
generates a header. It will append new text to the current debug
message even if the format buffer is empty. The syntax of the
DEBUGADD() macro is the same as that of the DEBUG() macro.
</para>

<para><programlisting format="linespecific">
    DEBUG( 0, ("This is the first line.\n" ) );
    DEBUGADD( 0, ("This is the second line.\nThis is the third line.\n" ) );
</programlisting></para>

<para>Produces</para>

<para><programlisting format="linespecific">
    [1998/07/30 16:00:51, 0] file.c:function(512)
      This is the first line.
      This is the second line.
      This is the third line.
</programlisting></para>

</sect1>

<sect1>
<title>The DEBUGLVL() Macro</title>

<para>
One of the problems with the DEBUG() macro was that DEBUG() lines
tended to get a bit long. Consider this example from
nmbd_sendannounce.c:
</para>

<para><programlisting format="linespecific">
  DEBUG(3,("send_local_master_announcement: type %x for name %s on subnet %s for workgroup %s\n",
            type, global_myname, subrec-&gt;subnet_name, work-&gt;work_group));
</programlisting></para>

<para>
One solution to this is to break it down using DEBUG() and DEBUGADD(),
as follows:
</para>

<para><programlisting format="linespecific">
  DEBUG( 3, ( "send_local_master_announcement: " ) );
  DEBUGADD( 3, ( "type %x for name %s ", type, global_myname ) );
  DEBUGADD( 3, ( "on subnet %s ", subrec-&gt;subnet_name ) );
  DEBUGADD( 3, ( "for workgroup %s\n", work-&gt;work_group ) );
</programlisting></para>

<para>
A similar, but arguably nicer approach is to use the DEBUGLVL() macro.
This macro returns True if the message level is less than or equal to
the global DEBUGLEVEL value, so:
</para>

<para><programlisting format="linespecific">
  if( DEBUGLVL( 3 ) )
    {
    dbgtext( "send_local_master_announcement: " );
    dbgtext( "type %x for name %s ", type, global_myname );
    dbgtext( "on subnet %s ", subrec-&gt;subnet_name );
    dbgtext( "for workgroup %s\n", work-&gt;work_group );
    }
</programlisting></para>

<para>(The dbgtext() function is explained below.)</para>

<para>There are a few advantages to this scheme:</para>
<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><para>
The test is performed only once.
</para></listitem>
<listitem><para>
You can allocate variables off of the stack that will only be used
within the DEBUGLVL() block.
</para></listitem>
<listitem><para>
Processing that is only relevant to debug output can be contained
within the DEBUGLVL() block.
</para></listitem>
</orderedlist>

</sect1>

<sect1>
<title>New Functions</title>

<sect2>
<title>dbgtext()</title>
<para>
This function prints debug message text to the debug file (and
possibly to syslog) via the format buffer. The function uses a
variable argument list just like printf() or Debug1(). The
input is printed into a buffer using the vslprintf() function,
and then passed to format_debug_text().

If you use DEBUGLVL() you will probably print the body of the
message using dbgtext(). 
</para>
</sect2>

<sect2>
<title>dbghdr()</title>
<para>
This is the function that writes a debug message header.
Headers are not processed via the format buffer. Also note that
if the format buffer is not empty, a call to dbghdr() will not
produce any output. See the comments in dbghdr() for more info.
</para>

<para>
It is not likely that this function will be called directly. It
is used by DEBUG() and DEBUGADD().
</para>
</sect2>

<sect2>
<title>format_debug_text()</title>
<para>
This is a static function in debug.c. It stores the output text
for the body of the message in a buffer until it encounters a
newline. When the newline character is found, the buffer is
written to the debug file via the Debug1() function, and the
buffer is reset. This allows us to add the indentation at the
beginning of each line of the message body, and also ensures
that the output is written a line at a time (which cleans up
syslog output).
</para>
</sect2>
</sect1>
</chapter>
	<chapter id="internals">
<chapterinfo>
	<author>
		<firstname>David</firstname><surname>Chappell</surname>
		<affiliation>
			<address format="linespecific"><email>David.Chappell@mail.trincoll.edu</email></address>
		</affiliation>
	</author>
	<pubdate>8 May 1996</pubdate>
</chapterinfo>

<title>Samba Internals</title>

<sect1>
<title>Character Handling</title>
<para>
This section describes character set handling in Samba, as implemented in
Samba 3.0 and above
</para>

<para>
In the past Samba had very ad-hoc character set handling. Scattered
throughout the code were numerous calls which converted particular
strings to/from DOS codepages. The problem is that there was no way of
telling if a particular char* is in dos codepage or unix
codepage. This led to a nightmare of code that tried to cope with
particular cases without handlingt the general case.
</para>
</sect1>

<sect1>
<title>The new functions</title>

<para>
The new system works like this:
</para>

<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><para>
	all char* strings inside Samba are "unix" strings. These are
	multi-byte strings that are in the charset defined by the "unix
	charset" option in smb.conf. 
</para></listitem>

<listitem><para>
	there is no single fixed character set for unix strings, but any
	character set that is used does need the following properties:
	</para>
	<orderedlist inheritnum="ignore" continuation="restarts">
	
	<listitem><para>
		must not contain NULLs except for termination
	</para></listitem>

	<listitem><para>
		must be 7-bit compatible with C strings, so that a constant
		string or character in C will be byte-for-byte identical to the
		equivalent string in the chosen character set. 
	</para></listitem>
	
	<listitem><para>
		when you uppercase or lowercase a string it does not become
		longer than the original string
	</para></listitem>

	<listitem><para>
		must be able to correctly hold all characters that your client
		will throw at it
	</para></listitem>
	</orderedlist>
	
	<para>
	For example, UTF-8 is fine, and most multi-byte asian character sets
	are fine, but UCS2 could not be used for unix strings as they
	contain nulls.
	</para>
</listitem>

<listitem><para>
	when you need to put a string into a buffer that will be sent on the
	wire, or you need a string in a character set format that is
	compatible with the clients character set then you need to use a
	pull_ or push_ function. The pull_ functions pull a string from a
	wire buffer into a (multi-byte) unix string. The push_ functions
	push a string out to a wire buffer. 
</para></listitem>

<listitem><para>
	the two main pull_ and push_ functions you need to understand are
	pull_string and push_string. These functions take a base pointer
	that should point at the start of the SMB packet that the string is
	in. The functions will check the flags field in this packet to
	automatically determine if the packet is marked as a unicode packet,
	and they will choose whether to use unicode for this string based on
	that flag. You may also force this decision using the STR_UNICODE or
	STR_ASCII flags. For use in smbd/ and libsmb/ there are wrapper
	functions clistr_ and srvstr_ that call the pull_/push_ functions
	with the appropriate first argument.
	</para>
	
	<para>
	You may also call the pull_ascii/pull_ucs2 or push_ascii/push_ucs2
	functions if you know that a particular string is ascii or
	unicode. There are also a number of other convenience functions in
	charcnv.c that call the pull_/push_ functions with particularly
	common arguments, such as pull_ascii_pstring()
	</para>
</listitem>

<listitem><para>
	The biggest thing to remember is that internal (unix) strings in Samba
	may now contain multi-byte characters. This means you cannot assume
	that characters are always 1 byte long. Often this means that you will
	have to convert strings to ucs2 and back again in order to do some
	(seemingly) simple task. For examples of how to do this see functions
	like strchr_m(). I know this is very slow, and we will eventually
	speed it up but right now we want this stuff correct not fast.
</para></listitem>

<listitem><para>
	all lp_ functions now return unix strings. The magic "DOS" flag on
	parameters is gone.
</para></listitem>

<listitem><para>
	all vfs functions take unix strings. Don't convert when passing to them
</para></listitem>

</orderedlist>

</sect1>

<sect1>
<title>Macros in byteorder.h</title>

<para>
This section describes the macros defined in byteorder.h.  These macros 
are used extensively in the Samba code.
</para>

<sect2>
<title>CVAL(buf,pos)</title>

<para>
returns the byte at offset pos within buffer buf as an unsigned character.
</para>
</sect2>

<sect2>
<title>PVAL(buf,pos)</title>
<para>returns the value of CVAL(buf,pos) cast to type unsigned integer.</para>
</sect2>

<sect2>
<title>SCVAL(buf,pos,val)</title>
<para>sets the byte at offset pos within buffer buf to value val.</para>
</sect2>

<sect2>
<title>SVAL(buf,pos)</title>
<para>
	returns the value of the unsigned short (16 bit) little-endian integer at 
	offset pos within buffer buf.  An integer of this type is sometimes
	refered to as "USHORT".
</para>
</sect2>

<sect2>
<title>IVAL(buf,pos)</title>
<para>returns the value of the unsigned 32 bit little-endian integer at offset 
pos within buffer buf.</para>
</sect2>

<sect2>
<title>SVALS(buf,pos)</title>
<para>returns the value of the signed short (16 bit) little-endian integer at 
offset pos within buffer buf.</para>
</sect2>

<sect2>
<title>IVALS(buf,pos)</title>
<para>returns the value of the signed 32 bit little-endian integer at offset pos
within buffer buf.</para>
</sect2>

<sect2>
<title>SSVAL(buf,pos,val)</title>
<para>sets the unsigned short (16 bit) little-endian integer at offset pos within 
buffer buf to value val.</para>
</sect2>

<sect2>
<title>SIVAL(buf,pos,val)</title>
<para>sets the unsigned 32 bit little-endian integer at offset pos within buffer 
buf to the value val.</para>
</sect2>

<sect2>
<title>SSVALS(buf,pos,val)</title>
<para>sets the short (16 bit) signed little-endian integer at offset pos within 
buffer buf to the value val.</para>
</sect2>

<sect2>
<title>SIVALS(buf,pos,val)</title>
<para>sets the signed 32 bit little-endian integer at offset pos withing buffer
buf to the value val.</para>
</sect2>

<sect2>
<title>RSVAL(buf,pos)</title>
<para>returns the value of the unsigned short (16 bit) big-endian integer at 
offset pos within buffer buf.</para>
</sect2>

<sect2>
<title>RIVAL(buf,pos)</title>
<para>returns the value of the unsigned 32 bit big-endian integer at offset 
pos within buffer buf.</para>
</sect2>

<sect2>
<title>RSSVAL(buf,pos,val)</title>
<para>sets the value of the unsigned short (16 bit) big-endian integer at 
offset pos within buffer buf to value val.
refered to as "USHORT".</para>
</sect2>

<sect2>
<title>RSIVAL(buf,pos,val)</title>
<para>sets the value of the unsigned 32 bit big-endian integer at offset 
pos within buffer buf to value val.</para>
</sect2>

</sect1>


<sect1>
<title>LAN Manager Samba API</title>

<para>
This section describes the functions need to make a LAN Manager RPC call.
This information had been obtained by examining the Samba code and the LAN
Manager 2.0 API documentation.  It should not be considered entirely
reliable.
</para>

<para>
<programlisting format="linespecific">
call_api(int prcnt, int drcnt, int mprcnt, int mdrcnt, 
	char *param, char *data, char **rparam, char **rdata);
</programlisting>
</para>

<para>
This function is defined in client.c.  It uses an SMB transaction to call a
remote api.
</para>

<sect2>
<title>Parameters</title>

<para>The parameters are as follows:</para>

<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><para>
	prcnt: the number of bytes of parameters begin sent.
</para></listitem>
<listitem><para>
	drcnt:   the number of bytes of data begin sent.
</para></listitem>
<listitem><para>
	mprcnt:  the maximum number of bytes of parameters which should be returned
</para></listitem>
<listitem><para>
	mdrcnt:  the maximum number of bytes of data which should be returned
</para></listitem>
<listitem><para>
	param:   a pointer to the parameters to be sent.
</para></listitem>
<listitem><para>
	data:    a pointer to the data to be sent.
</para></listitem>
<listitem><para>
	rparam:  a pointer to a pointer which will be set to point to the returned
	parameters.  The caller of call_api() must deallocate this memory.
</para></listitem>
<listitem><para>
	rdata:   a pointer to a pointer which will be set to point to the returned 
	data.  The caller of call_api() must deallocate this memory.
</para></listitem>
</orderedlist>

<para>
These are the parameters which you ought to send, in the order of their
appearance in the parameter block:
</para>

<orderedlist inheritnum="ignore" continuation="restarts">

<listitem><para>
An unsigned 16 bit integer API number.  You should set this value with
SSVAL().  I do not know where these numbers are described.
</para></listitem>

<listitem><para>
An ASCIIZ string describing the parameters to the API function as defined
in the LAN Manager documentation.  The first parameter, which is the server
name, is ommited.  This string is based uppon the API function as described
in the manual, not the data which is actually passed.
</para></listitem>

<listitem><para>
An ASCIIZ string describing the data structure which ought to be returned.
</para></listitem>

<listitem><para>
Any parameters which appear in the function call, as defined in the LAN
Manager API documentation, after the "Server" and up to and including the
"uLevel" parameters.
</para></listitem>

<listitem><para>
An unsigned 16 bit integer which gives the size in bytes of the buffer we
will use to receive the returned array of data structures.  Presumably this
should be the same as mdrcnt.  This value should be set with SSVAL().
</para></listitem>

<listitem><para>
An ASCIIZ string describing substructures which should be returned.  If no 
substructures apply, this string is of zero length.
</para></listitem>

</orderedlist>

<para>
The code in client.c always calls call_api() with no data.  It is unclear
when a non-zero length data buffer would be sent.
</para>

</sect2>

<sect2>
<title>Return value</title>

<para>
The returned parameters (pointed to by rparam), in their order of appearance
are:</para>

<orderedlist inheritnum="ignore" continuation="restarts">

<listitem><para>
An unsigned 16 bit integer which contains the API function's return code. 
This value should be read with SVAL().
</para></listitem>

<listitem><para>
An adjustment which tells the amount by which pointers in the returned
data should be adjusted.  This value should be read with SVAL().  Basically, 
the address of the start of the returned data buffer should have the returned
pointer value added to it and then have this value subtracted from it in
order to obtain the currect offset into the returned data buffer.
</para></listitem>

<listitem><para>
A count of the number of elements in the array of structures returned. 
It is also possible that this may sometimes be the number of bytes returned.
</para></listitem>
</orderedlist>

<para>
When call_api() returns, rparam points to the returned parameters.  The
first if these is the result code.  It will be zero if the API call
suceeded.  This value by be read with "SVAL(rparam,0)".
</para>

<para>
The second parameter may be read as "SVAL(rparam,2)".  It is a 16 bit offset
which indicates what the base address of the returned data buffer was when
it was built on the server.  It should be used to correct pointer before
use.
</para>

<para>
The returned data buffer contains the array of returned data structures. 
Note that all pointers must be adjusted before use.  The function
fix_char_ptr() in client.c can be used for this purpose.
</para>

<para>
The third parameter (which may be read as "SVAL(rparam,4)") has something to
do with indicating the amount of data returned or possibly the amount of
data which can be returned if enough buffer space is allowed.
</para>

</sect2>
</sect1>

<sect1>
<title>Code character table</title>
<para>
Certain data structures are described by means of ASCIIz strings containing
code characters.  These are the code characters:
</para>

<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><para>
W	a type byte little-endian unsigned integer
</para></listitem>
<listitem><para>
N	a count of substructures which follow
</para></listitem>
<listitem><para>
D	a four byte little-endian unsigned integer
</para></listitem>
<listitem><para>
B	a byte (with optional count expressed as trailing ASCII digits)
</para></listitem>
<listitem><para>
z	a four byte offset to a NULL terminated string
</para></listitem>
<listitem><para>
l	a four byte offset to non-string user data
</para></listitem>
<listitem><para>
b	an offset to data (with count expressed as trailing ASCII digits)
</para></listitem>
<listitem><para>
r	pointer to returned data buffer???
</para></listitem>
<listitem><para>
L	length in bytes of returned data buffer???
</para></listitem>
<listitem><para>
h	number of bytes of information available???
</para></listitem>
</orderedlist>

</sect1>
</chapter>
	<chapter id="CodingSuggestions">
<chapterinfo>
	<author>
		<firstname>Steve</firstname><surname>French</surname>
	</author>
	<author>
		<firstname>Simo</firstname><surname>Sorce</surname>
	</author>
	<author>
		<firstname>Andrew</firstname><surname>Bartlett</surname>
	</author>
	<author>
		<firstname>Tim</firstname><surname>Potter</surname>
	</author>
	<author>
		<firstname>Martin</firstname><surname>Pool</surname>
	</author>
</chapterinfo>

<title>Coding Suggestions</title>

<para>
So you want to add code to Samba ...
</para>

<para>
One of the daunting tasks facing a programmer attempting to write code for
Samba is understanding the various coding conventions used by those most
active in the project.  These conventions were mostly unwritten and helped
improve either the portability, stability or consistency of the code. This
document will attempt to document a few of the more important coding
practices used at this time on the Samba project.  The coding practices are
expected to change slightly over time, and even to grow as more is learned
about obscure portability considerations.  Two existing documents
<filename moreinfo="none">samba/source/internals.doc</filename> and 
<filename moreinfo="none">samba/source/architecture.doc</filename> provide
additional information.
</para>

<para>
The loosely related question of coding style is very personal and this
document does not attempt to address that subject, except to say that I
have observed that eight character tabs seem to be preferred in Samba
source.  If you are interested in the topic of coding style, two oft-quoted
documents are:
</para>

<para>
<ulink url="http://lxr.linux.no/source/Documentation/CodingStyle">http://lxr.linux.no/source/Documentation/CodingStyle</ulink>
</para>

<para>
<ulink url="http://www.fsf.org/prep/standards_toc.html">http://www.fsf.org/prep/standards_toc.html</ulink>
</para>

<para>
But note that coding style in Samba varies due to the many different
programmers who have contributed.
</para>

<para>
Following are some considerations you should use when adding new code to
Samba.  First and foremost remember that:
</para>

<para>
Portability is a primary consideration in adding function, as is network
compatability with de facto, existing, real world CIFS/SMB implementations.
There are lots of platforms that Samba builds on so use caution when adding
a call to a library function that is not invoked in existing Samba code.
Also note that there are many quite different SMB/CIFS clients that Samba
tries to support, not all of which follow the SNIA CIFS Technical Reference
(or the earlier Microsoft reference documents or the X/Open book on the SMB
Standard) perfectly.
</para>

<para>
Here are some other suggestions:
</para>

<orderedlist inheritnum="ignore" continuation="restarts">

<listitem><para>
	use d_printf instead of printf for display text
	reason: enable auto-substitution of translated language text 
</para></listitem>

<listitem><para>
	use SAFE_FREE instead of free
	reason: reduce traps due to null pointers
</para></listitem>

<listitem><para>
	don't use bzero use memset, or ZERO_STRUCT and ZERO_STRUCTP macros
	reason: not POSIX
</para></listitem>

<listitem><para>
	don't use strcpy and strlen (use safe_* equivalents)
	reason: to avoid traps due to buffer overruns
</para></listitem>

<listitem><para>
	don't use getopt_long, use popt functions instead
	reason: portability
</para></listitem>

<listitem><para>
	explicitly add const qualifiers on parm passing in functions where parm
	is input only (somewhat controversial but const can be #defined away)
</para></listitem>

<listitem><para>
	when passing a va_list as an arg, or assigning one to another
	please use the VA_COPY() macro
	reason: on some platforms, va_list is a struct that must be 
	initialized in each function...can SEGV if you don't.
</para></listitem>

<listitem><para>
	discourage use of threads
	reason: portability (also see architecture.doc)
</para></listitem>

<listitem><para>
	don't explicitly include new header files in C files - new h files 
	should be included by adding them once to includes.h
	reason: consistency
</para></listitem>

<listitem><para>
	don't explicitly extern functions (they are autogenerated by 
	"make proto" into proto.h)
	reason: consistency
</para></listitem>

<listitem><para>
	use endian safe macros when unpacking SMBs (see byteorder.h and
	internals.doc)
	reason: not everyone uses Intel
</para></listitem>

<listitem><para>
	Note Unicode implications of charset handling (see internals.doc).  See
	pull_*  and push_* and convert_string functions.
	reason: Internationalization
</para></listitem>

<listitem><para>
	Don't assume English only
	reason: See above
</para></listitem>

<listitem><para>
	Try to avoid using in/out parameters (functions that return data which
	overwrites input parameters)
	reason: Can cause stability problems
</para></listitem>

<listitem><para>
	Ensure copyright notices are correct, don't append Tridge's name to code
	that he didn't write.  If you did not write the code, make sure that it
	can coexist with the rest of the Samba GPLed code.
</para></listitem>

<listitem><para>
	Consider usage of DATA_BLOBs for length specified byte-data.
	reason: stability
</para></listitem>

<listitem><para>
	Take advantage of tdbs for database like function
	reason: consistency
</para></listitem>

<listitem><para>
	Don't access the SAM_ACCOUNT structure directly, they should be accessed
	via pdb_get...() and pdb_set...() functions.
	reason: stability, consistency
</para></listitem>

<listitem><para>
	Don't check a password directly against the passdb, always use the
	check_password() interface.
	reason: long term pluggability
</para></listitem>

<listitem><para>
	Try to use asprintf rather than pstrings and fstrings where possible
</para></listitem>

<listitem><para>
	Use normal C comments / * instead of C++ comments // like
	this.  Although the C++ comment format is part of the C99
	standard, some older vendor C compilers do not accept it.
</para></listitem>

<listitem><para>
	Try to write documentation for API functions and structures
	explaining the point of the code, the way it should be used, and
	any special conditions or results.  Mark these with a double-star
	comment start / ** so that they can be picked up by Doxygen, as in
	this file.
</para></listitem>

<listitem><para>
	Keep the scope narrow. This means making functions/variables
	static whenever possible. We don't want our namespace
	polluted. Each module should have a minimal number of externally
	visible functions or variables.
</para></listitem>

<listitem><para>
	Use function pointers to keep knowledge about particular pieces of
	code isolated in one place. We don't want a particular piece of
	functionality to be spread out across lots of places - that makes
	for fragile, hand to maintain code. Instead, design an interface
	and use tables containing function pointers to implement specific
	functionality. This is particularly important for command
	interpreters. 
</para></listitem>

<listitem><para>
	Think carefully about what it will be like for someone else to add
	to and maintain your code. If it would be hard for someone else to
	maintain then do it another way. 
</para></listitem>

</orderedlist>

<para>
The suggestions above are simply that, suggestions, but the information may
help in reducing the routine rework done on new code.  The preceeding list
is expected to change routinely as new support routines and macros are
added.
</para>
</chapter>
	<chapter id="contributing">
<chapterinfo>
	<author>
<firstname>Jelmer</firstname><othername>R.</othername><surname>Vernooij</surname><othername>R.</othername>
<affiliation>
	<orgname>The Samba Team</orgname>
	<address format="linespecific"><email>jelmer@samba.org</email></address>
</affiliation></author>
</chapterinfo>

<title>Contributing code</title>

<para>Here are a few tips and notes that might be useful if you are 
	interested in modifying samba source code and getting it into 
	samba's main branch.</para>

<variablelist>
	<varlistentry>
		<term>Retrieving the source</term>

		<listitem>
		<para>In order to contribute code to samba, make sure you have the 
			latest source. Retrieving the samba source code from CVS is 
			documented in the appendix of the Samba HOWTO Collection.
		</para>
		</listitem>
	</varlistentry>

	<varlistentry>
		<term>Discuss large modifications with team members</term>
		<listitem>
		<para>Please discuss large modifications you are going to make 
		with members of the samba team. Some parts of the samba code 
		have one or more 'owners' - samba developers who wrote most 
		of the code and maintain it. 
		</para>

		<para>This way you can avoid spending your time and effort on 
		something that is not going to make it into the main samba branch 
		because someone else was working on the same thing or because your 
		implementation is not the correct one.
		</para>
		</listitem>
	</varlistentry>

	<varlistentry>
		<term>Patch format</term>
		<listitem>
		<para>Patches to the samba tree should be in unified diff format, 
			e.g. files generated by <userinput moreinfo="none">diff -u</userinput>. 
		</para>

		<para>If you are modifying a copy of samba you retrieved from CVS, 
		you can easily generate a diff file of these changes by running 
		<userinput moreinfo="none">cvs diff -u</userinput>.</para>			
		</listitem>
	</varlistentry>

	<varlistentry>
		<term>Points of attention when modifying samba source code</term>
		<listitem><para>
		<itemizedlist>
		<listitem><para>Don't simply copy code from other places and modify it until it
		works. Code needs to be clean and logical. Duplicate 
		code is to be avoided.</para></listitem>
		<listitem><para>Test your patch. It might take a while before one of us looks 
		at your patch so it will take longer before your patch when your patch 
		needs to go thru the review cycle again.</para></listitem>
		<listitem><para>Don't put separate patches in one large diff file. This makes 
		it harder to read, understand and test the patch. You might 
		also risk not getting a good patch committed because you mixed it 
		with one that had issues. </para></listitem>
		<listitem><para>Make sure your patch complies to the samba coding style as 
 		suggested in the coding-suggestions chapter. </para></listitem>
			</itemizedlist>
		</para>
		</listitem>
	</varlistentry>

	<varlistentry>
		<term>Sending in bugfixes</term>
		<listitem>
		<para>Bugfixes to bugs in samba should be submitted to samba's
		<ulink url="https://bugzilla.samba.org/">bugzilla system</ulink>, 
		along with a description of the bug.
		</para>
		</listitem>
	</varlistentry>

	<varlistentry>
		<term>Sending in feature patches</term>
		<listitem>
		<para>Send feature patches along with a description of what the 
		patch is supposed to do to the 
		<ulink url="mailto:samba-technical@samba.org">Samba-technical mailinglist</ulink> and possibly to a samba team member who is (one of the) 'owners'
		of the code you made modifications to. We are all busy people 
		so everybody tends to 'let one of the others handle it'. If nobody 
		responded to your patch for a week, try to send it again until you 
		get a response from one of us.
		</para></listitem>
	</varlistentry>

	<varlistentry>
		<term>Feedback on your patch</term>
		<listitem>
		<para>One of the team members will look at your patch and either 
		commit your patch or give comments why he won't apply it. In the 
		latter case you can fix your patch and re-send it until 
		your patch is approved.</para>
		</listitem>
	</varlistentry>
</variablelist>

</chapter>
	<chapter id="modules">
<chapterinfo>
	<author>
		<firstname>Jelmer</firstname><surname>Vernooij</surname>
		<affiliation>
			<orgname>Samba Team</orgname>
			<address format="linespecific"><email>jelmer@samba.org</email></address>
		</affiliation>
	</author>
	<pubdate> 19 March 2003 </pubdate>
</chapterinfo>

<title>Modules</title>

<sect1>
<title>Advantages</title>

<para>
The new modules system has the following advantages:
</para>

<simplelist type="vert">
<member>Transparent loading of static and shared modules (no need 
for a subsystem to know about modules)</member>
<member>Simple selection between shared and static modules at configure time</member>
<member>"preload modules" option for increasing performance for stable modules</member>
<member>No nasty #define stuff anymore</member>
<member>All backends are available as plugin now (including pdb_ldap and pdb_tdb)</member>
</simplelist>
</sect1>

<sect1>
<title>Loading modules</title>

<para>
Some subsystems in samba use different backends. These backends can be 
either statically linked in to samba or available as a plugin. A subsystem 
should have a function that allows a module to register itself. For example, 
the passdb subsystem has: 
</para>

<para><programlisting format="linespecific">
NTSTATUS smb_register_passdb(int version, const char *name, pdb_init_function init);
</programlisting></para>

<para>
This function will be called by the initialisation function of the module to 
register itself. 
</para>

<sect2>
<title>Static modules</title>

<para>
The modules system compiles a list of initialisation functions for the 
static modules of each subsystem. This is a define. For example, 
it is here currently (from <filename moreinfo="none">include/config.h</filename>): 
</para>

<para><programlisting format="linespecific">
/* Static init functions */
#define static_init_pdb { pdb_mysql_init(); pdb_ldap_init(); pdb_smbpasswd_init(); pdb_tdbsam_init(); pdb_guest_init();}
</programlisting></para>

<para>
These functions should be called before the subsystem is used. That 
should be done when the subsystem is initialised or first used. 
</para>

</sect2>

<sect2>
<title>Shared modules</title>

<para>
If a subsystem needs a certain backend, it should check if it has 
already been registered. If the backend hasn't been registered already, 
the subsystem should call smb_probe_module(char *subsystem, char *backend).
This function tries to load the correct module from a certain path
($LIBDIR/subsystem/backend.so). If the first character in 'backend' 
is a slash, smb_probe_module() tries to load the module from the 
absolute path specified in 'backend'.
</para>

<para>After smb_probe_module() has been executed, the subsystem 
should check again if the module has been registered. 
</para>

</sect2>
</sect1>

<sect1>
<title>Writing modules</title>

<para>
Each module has an initialisation function. For modules that are 
included with samba this name is '<replaceable>subsystem</replaceable>_<replaceable>backend</replaceable>_init'. For external modules (that will never be built-in, but only available as a module) this name is always 'init_module'. (In the case of modules included with samba, the configure system will add a #define subsystem_backend_init() init_module()).
The prototype for these functions is:
</para>

<para><programlisting format="linespecific">
NTSTATUS init_module(void);
</programlisting></para>

<para>This function should call one or more 
registration functions. The function should return NT_STATUS_OK on success and  
NT_STATUS_UNSUCCESSFUL or a more useful nt error code on failure.</para>

<para>For example, pdb_ldap_init() contains: </para>

<para><programlisting format="linespecific">
NTSTATUS pdb_ldap_init(void)
{
smb_register_passdb(PASSDB_INTERFACE_VERSION, "ldapsam", pdb_init_ldapsam);
smb_register_passdb(PASSDB_INTERFACE_VERSION, "ldapsam_nua", pdb_init_ldapsam_nua);
	return NT_STATUS_OK;
}
</programlisting></para>

<sect2>
<title>Static/Shared selection in configure.in</title>

<para>
Some macros in configure.in generate the various defines and substs that 
are necessary for the system to work correct. All modules that should 
be built by default have to be added to the variable 'default_modules'. 
For example, if ldap is found, pdb_ldap is added to this variable.
</para>

<para>
On the bottom of configure.in, SMB_MODULE() should be called 
for each module and SMB_SUBSYSTEM() for each subsystem.
</para>

<para>Syntax:</para>

<para><programlisting format="linespecific">
SMB_MODULE(<replaceable>subsystem</replaceable>_<replaceable>backend</replaceable>, <replaceable>object files</replaceable>, <replaceable>plugin name</replaceable>, <replaceable>subsystem name</replaceable>, <replaceable>static_action</replaceable>, <replaceable>shared_action</replaceable>)
SMB_SUBSYSTEM(<replaceable>subsystem</replaceable>,<replaceable>depfile</replaceable>)
</programlisting></para>

<para>The depfile for a certain subsystem is the file that calls the 
initialisation functions for the statically built in modules.</para>

<para>
<replaceable>@SUBSYSTEM_MODULES@</replaceable> in Makefile.in will 
be replaced with the names of the plugins to build.
</para>

<para>You must make sure all .c files that contain defines that can 
be changed by ./configure are rebuilded in the 'modules_clean' make target. 
Practically, this means all c files that contain <literal>static_init_subsystem;</literal> calls need to be rebuilded.
</para>

<note>
<para>
There currently also is a configure.in command called SMB_MODULE_PROVIVES().
This is used for modules that register multiple things. It should not 
be used as probing will most likely disappear in the future.</para>
</note>

</sect2>
</sect1>
</chapter>
</part>

<part>
	<title>Samba Subsystems</title>
	
	<chapter id="rpc-plugin">
<chapterinfo>
	<author>
		<firstname>Anthony</firstname><surname>Liguori</surname>
		<affiliation>
			<orgname>IBM</orgname>
			<address format="linespecific"><email>aliguor@us.ibm.com</email></address>
		</affiliation>
	</author>
	<author>
		<firstname>Jelmer</firstname><surname>Vernooij</surname>
		<affiliation>
			<orgname>Samba Team</orgname>
			<address format="linespecific"><email>jelmer@samba.org</email></address>
		</affiliation>
	</author>
	<pubdate>January 2003</pubdate>
</chapterinfo>

<title>RPC Pluggable Modules</title>

<sect1>
<title>About</title>

<para>
This document describes how to make use the new RPC Pluggable Modules features
of Samba 3.0.  This architecture was added to increase the maintainability of
Samba allowing RPC Pipes to be worked on separately from the main CVS branch.
The RPM architecture will also allow third-party vendors to add functionality
to Samba through plug-ins.
</para>

</sect1>

<sect1>
<title>General Overview</title>

<para>
When an RPC call is sent to smbd, smbd tries to load a shared library by the
name <filename moreinfo="none">librpc_&lt;pipename&gt;.so</filename> to handle the call if
it doesn't know how to handle the call internally.  For instance, LSA calls
are handled by <filename moreinfo="none">librpc_lsass.so</filename>..
These shared libraries should be located in the <filename moreinfo="none">&lt;sambaroot&gt;/lib/rpc</filename>.  smbd then attempts to call the init_module function within
the shared library. Check the chapter on modules for more information.
</para>

<para>
In the init_module function, the library should call 
rpc_pipe_register_commands().  This function takes the following arguments:
</para>

<para><programlisting format="linespecific">
NTSTATUS rpc_pipe_register_commands(int version, const char *clnt, const char *srv,
                               const struct api_struct *cmds, int size);
</programlisting></para>

<variablelist>

<varlistentry><term>version</term>
<listitem><para>Version number of the RPC interface. Use the define <emphasis>SMB_RPC_INTERFACE_VERSION</emphasis> for this 
argument.</para></listitem>
</varlistentry>
		
<varlistentry><term>clnt</term>
<listitem><para>the Client name of the named pipe</para></listitem>
</varlistentry>

<varlistentry><term>srv</term>
<listitem><para>the Server name of the named pipe</para></listitem>
</varlistentry>

<varlistentry><term>cmds</term>
<listitem><para>a list of api_structs that map RPC ordinal numbers to function calls</para></listitem>
</varlistentry>

<varlistentry><term>size</term>
<listitem><para>the number of api_structs contained in cmds</para></listitem>
</varlistentry>

</variablelist>

<para>
See rpc_server/srv_reg.c and rpc_server/srv_reg_nt.c for a small example of
how to use this library.
</para>

</sect1>
</chapter>
	<chapter id="vfs">
<chapterinfo>
	<author>
		<firstname>Alexander</firstname><surname>Bokovoy</surname>
		<affiliation>
			<address format="linespecific"><email>ab@samba.org</email></address>
		</affiliation>
	</author>
	<author>
		<firstname>Stefan</firstname><surname>Metzmacher</surname>
		<affiliation>
			<address format="linespecific"><email>metze@samba.org</email></address>
		</affiliation>
	</author>
	<pubdate> 27 May 2003 </pubdate>
</chapterinfo>

<title>VFS Modules</title>

<sect1>
<title>The Samba (Posix) VFS layer</title>

<para>While most of Samba deployments are done using POSIX-compatible
operating systems, there is clearly more to a file system than what is
required by POSIX when it comes to adopting semantics of NT file
system. Since Samba 2.2 all file-system related operations go through
an abstraction layer for virtual file system (VFS) that is modelled
after both POSIX and additional functions needed to transform NTFS
semantics.
</para>

<para>
This abstraction layer now provides more features than a regular POSIX
file system could fill in. It is not required that all of them should
be implemented by your particular file system.  However, when those
features are available, Samba would advertize them to a CIFS client
and they might be used by an application and in case of Windows client
that might mean a client expects even more additional functionality
when it encounters those features. There is a practical reason to
allow handling of this snowfall without modifying the Samba core and
it is fulfilled by providing an infrastructure to dynamically load VFS
modules at run time.
</para>

<para>Each VFS module could implement a number of VFS operations. The
way it does it is irrelevant, only two things actually matter: whether
specific implementation wants to cooperate with other modules'
implementations or not, and whether module needs to store additional
information that is specific to a context it is operating in. Multiple
VFS modules could be loaded at the same time and it is even possible
to load several instances of the same VFS module with different
parameters.
</para>

<sect2>
<title>The general interface</title>

<para>A VFS module has three major components:
<itemizedlist>
<listitem><emphasis>An initialization function</emphasis> that is
called during the module load to register implemented
operations.</listitem>
<listitem><emphasis>An operations table</emphasis> representing a
mapping between statically defined module functions and VFS layer
operations.</listitem>
<listitem><emphasis>Module functions</emphasis> that do actual
work.</listitem>
</itemizedlist>
</para>

<para>While this structure has been first applied to the VFS
subsystem, it is now commonly used across all Samba 3 subsystems that
support loadable modules. In fact, one module could provide a number
of interfaces to different subsystems by exposing different
<emphasis>operation tables</emphasis> through separate
<emphasis>initialization functions</emphasis>.</para>

<para><emphasis>An initialization function</emphasis> is used to
register module with Samba run-time. As Samba internal structures and
API are changed over lifetime, each released version has a VFS
interface version that is increased as VFS development progresses or
any of underlying Samba structures are changed in binary-incompatible
way. When VFS module is compiled in, VFS interface version of that
Samba environment is embedded into the module's binary object and is
checked by the Samba core upon module load. If VFS interface number
reported by the module isn't the same Samba core knows about, version
conflict is detected and module dropped to avoid any potential memory
corruption when accessing (changed) Samba structures.
</para>

<para>Therefore, initialization function passes three parameters to the
VFS registration function, <literal moreinfo="none">smb_register_vfs()</literal>
<itemizedlist>
  <listitem><emphasis>interface version number</emphasis>, as constant
  <literal moreinfo="none">SMB_VFS_INTERFACE_VERSION</literal>, </listitem>
  <listitem><emphasis>module name</emphasis>, under which Samba core
  will know it, and</listitem>
  <listitem><emphasis>an operations' table</emphasis>.</listitem>
</itemizedlist>
</para>

<para>The <emphasis>operations' table</emphasis> defines which
functions in the module would correspond to specific VFS operations
and how those functions would co-operate with the rest of VFS
subsystem. Each operation could perform in a following ways:
<itemizedlist>
  <listitem><emphasis>transparent</emphasis>, meaning that while
  operation is overriden, the module will still call a previous
  implementation, before or after its own action. This mode is
  indicated by the constant
  <literal moreinfo="none">SMB_VFS_LAYER_TRANSPARENT</literal>;
  </listitem>
  <listitem><emphasis>opaque</emphasis>, for the implementations that
  are terminating sequence of actions. For example, it is used to
  implement POSIX operation on top of non-POSIX file system or even
  not a file system at all, like a database for a personal audio
  collection. Use constant <literal moreinfo="none">SMB_VFS_LAYER_OPAQUE</literal> for
  this mode;</listitem>
  <listitem><emphasis>splitter</emphasis>, a way when some file system
  activity is done in addition to the transparently calling previous
  implentation. This usually involves mangling the result of that call
  before returning it back to the caller. This mode is selected by
  <literal moreinfo="none">SMB_VFS_LAYER_SPLITTER</literal> constant;</listitem>
  <listitem><emphasis>logger</emphasis> does not change anything or
  performs any additional VFS operations. When
  <emphasis>logger</emphasis> module acts, information about
  operations is logged somewhere using an external facility (or
  Samba's own debugging tools) but not the VFS layer. In order to
  describe this type of activity use constant
  <literal moreinfo="none">SMB_VFS_LAYER_LOGGER</literal>;
  </listitem>
  <listitem>On contrary, <emphasis>scanner</emphasis> module does call
  other VFS operations while processing the data that goes through the
  system. This type of operation is indicated by the
  <literal moreinfo="none">SMB_VFS_LAYER_SCANNER</literal> constant.</listitem>
</itemizedlist>
</para>

<para>Fundamentally, there are three types:
<emphasis>transparent</emphasis>, <emphasis>opaque</emphasis>, and
<emphasis>logger</emphasis>. <emphasis>Splitter</emphasis> and
<emphasis>scanner</emphasis> may confuse developers (and indeed they
are confused as our experience has shown) but this separation is to
better expose the nature of a module's actions. Most of modules
developed so far are either one of those three fundamental types with
transparent and opaque being prevalent.
</para>

<para>
Each VFS operation has a vfs_op_type, a function pointer and a handle
pointer in the struct vfs_ops and tree macros to make it easier to
call the operations.  (Take a look at
<filename moreinfo="none">include/vfs.h</filename> and
<filename moreinfo="none">include/vfs_macros.h</filename>.)
</para>

<para><programlisting format="linespecific">
typedef enum _vfs_op_type {
	SMB_VFS_OP_NOOP = -1,

	...

	/* File operations */

	SMB_VFS_OP_OPEN,
	SMB_VFS_OP_CLOSE,
	SMB_VFS_OP_READ,
	SMB_VFS_OP_WRITE,
	SMB_VFS_OP_LSEEK,
	SMB_VFS_OP_SENDFILE,

	...

	SMB_VFS_OP_LAST
} vfs_op_type;
</programlisting></para>

<para>This struct contains the function and handle pointers for all operations.<programlisting format="linespecific">
struct vfs_ops {
	struct vfs_fn_pointers {
		...
		
		/* File operations */
		
		int (*open)(struct vfs_handle_struct *handle,
			struct connection_struct *conn,
			const char *fname, int flags, mode_t mode);
		int (*close)(struct vfs_handle_struct *handle,
			struct files_struct *fsp, int fd);
		ssize_t (*read)(struct vfs_handle_struct *handle, 
			struct files_struct *fsp, int fd, void *data, size_t n);
		ssize_t (*write)(struct vfs_handle_struct *handle, 
			struct files_struct *fsp, int fd, 
			const void *data, size_t n);
		SMB_OFF_T (*lseek)(struct vfs_handle_struct *handle, 
			struct files_struct *fsp, int fd, 
			SMB_OFF_T offset, int whence);
		ssize_t (*sendfile)(struct vfs_handle_struct *handle, 
			int tofd, files_struct *fsp, int fromfd, 
			const DATA_BLOB *header, SMB_OFF_T offset, size_t count);

		...
	} ops;
	
	struct vfs_handles_pointers {
		...
		
		/* File operations */
		
		struct vfs_handle_struct *open;
		struct vfs_handle_struct *close;
		struct vfs_handle_struct *read;
		struct vfs_handle_struct *write;
		struct vfs_handle_struct *lseek;
		struct vfs_handle_struct *sendfile;
		
		...
	} handles;
};
</programlisting></para>

<para>
This macros SHOULD be used to call any vfs operation.
DO NOT ACCESS conn-&gt;vfs.ops.* directly !!!
<programlisting format="linespecific">
...
	
/* File operations */
#define SMB_VFS_OPEN(conn, fname, flags, mode) \
	((conn)-&gt;vfs.ops.open((conn)-&gt;vfs.handles.open,\
	 (conn), (fname), (flags), (mode)))
#define SMB_VFS_CLOSE(fsp, fd) \
	((fsp)-&gt;conn-&gt;vfs.ops.close(\
	(fsp)-&gt;conn-&gt;vfs.handles.close, (fsp), (fd)))
#define SMB_VFS_READ(fsp, fd, data, n) \
	((fsp)-&gt;conn-&gt;vfs.ops.read(\
	(fsp)-&gt;conn-&gt;vfs.handles.read,\
	 (fsp), (fd), (data), (n)))
#define SMB_VFS_WRITE(fsp, fd, data, n) \
	((fsp)-&gt;conn-&gt;vfs.ops.write(\
	(fsp)-&gt;conn-&gt;vfs.handles.write,\
	 (fsp), (fd), (data), (n)))
#define SMB_VFS_LSEEK(fsp, fd, offset, whence) \
	((fsp)-&gt;conn-&gt;vfs.ops.lseek(\
	(fsp)-&gt;conn-&gt;vfs.handles.lseek,\
	 (fsp), (fd), (offset), (whence)))
#define SMB_VFS_SENDFILE(tofd, fsp, fromfd, header, offset, count) \
	((fsp)-&gt;conn-&gt;vfs.ops.sendfile(\
	(fsp)-&gt;conn-&gt;vfs.handles.sendfile,\
	 (tofd), (fsp), (fromfd), (header), (offset), (count)))

...
</programlisting></para>

</sect2>

<sect2>
<title>Possible VFS operation layers</title>

<para>
These values are used by the VFS subsystem when building the conn-&gt;vfs 
and conn-&gt;vfs_opaque structs for a connection with multiple VFS modules. 
Internally, Samba differentiates only opaque and transparent layers at this process.
Other types are used for providing better diagnosing facilities.
</para>

<para>
Most modules will provide transparent layers. Opaque layer is for modules
which implement actual file system calls (like DB-based VFS). For example,
default POSIX VFS which is built in into Samba is an opaque VFS module.
</para>

<para>    
Other layer types (logger, splitter, scanner) were designed to provide different 
degree of transparency and for diagnosing VFS module behaviour.
</para>

<para>
Each module can implement several layers at the same time provided that only
one layer is used per each operation.
</para>

<para><programlisting format="linespecific">
typedef enum _vfs_op_layer {
	SMB_VFS_LAYER_NOOP = -1,	/* - For using in VFS module to indicate end of array */
					/*   of operations description */
	SMB_VFS_LAYER_OPAQUE = 0,	/* - Final level, does not call anything beyond itself */
	SMB_VFS_LAYER_TRANSPARENT,	/* - Normal operation, calls underlying layer after */
					/*   possibly changing passed data */
	SMB_VFS_LAYER_LOGGER,		/* - Logs data, calls underlying layer, logging may not */
					/*   use Samba VFS */
	SMB_VFS_LAYER_SPLITTER,		/* - Splits operation, calls underlying layer _and_ own facility, */
					/*   then combines result */
	SMB_VFS_LAYER_SCANNER		/* - Checks data and possibly initiates additional */
					/*   file activity like logging to files _inside_ samba VFS */
} vfs_op_layer;
</programlisting></para>

</sect2>

</sect1>

<sect1>
<title>The Interaction between the Samba VFS subsystem and the modules</title>

<sect2>
<title>Initialization and registration</title>

<para>
As each Samba module a VFS module should have a 
<programlisting format="linespecific">NTSTATUS vfs_example_init(void);</programlisting> function if it's staticly linked to samba or
<programlisting format="linespecific">NTSTATUS init_module(void);</programlisting> function if it's a shared module.
</para>

<para>
This should be the only non static function inside the module.
Global variables should also be static!
</para>

<para>
The module should register its functions via the
<programlisting format="linespecific">
NTSTATUS smb_register_vfs(int version, const char *name, vfs_op_tuple *vfs_op_tuples);
</programlisting> function.
</para>

<variablelist>

<varlistentry><term>version</term>
<listitem><para>should be filled with SMB_VFS_INTERFACE_VERSION</para></listitem>
</varlistentry>

<varlistentry><term>name</term>
<listitem><para>this is the name witch can be listed in the 
<literal>vfs objects</literal> parameter to use this module.</para></listitem>
</varlistentry>

<varlistentry><term>vfs_op_tuples</term>
<listitem><para>
this is an array of vfs_op_tuple's.
(vfs_op_tuples is descripted in details below.)
</para></listitem>
</varlistentry>

</variablelist>

<para>
For each operation the module wants to provide it has a entry in the 
vfs_op_tuple array.
</para>

<programlisting format="linespecific">
typedef struct _vfs_op_tuple {
	void* op;
	vfs_op_type type;
	vfs_op_layer layer;
} vfs_op_tuple;
</programlisting>

<variablelist>

<varlistentry><term>op</term>
<listitem><para>the function pointer to the specified function.</para></listitem>
</varlistentry>

<varlistentry><term>type</term>
<listitem><para>the vfs_op_type of the function to specified witch operation the function provides.</para></listitem>
</varlistentry>

<varlistentry><term>layer</term>
<listitem><para>the vfs_op_layer in whitch the function operates.</para></listitem>
</varlistentry>

</variablelist>

<para>A simple example:</para>

<programlisting format="linespecific">
static vfs_op_tuple example_op_tuples[] = {	
	{SMB_VFS_OP(example_connect),	SMB_VFS_OP_CONNECT,	SMB_VFS_LAYER_TRANSPARENT},
	{SMB_VFS_OP(example_disconnect),	SMB_VFS_OP_DISCONNECT,	SMB_VFS_LAYER_TRANSPARENT},

	{SMB_VFS_OP(example_rename),	SMB_VFS_OP_RENAME,	SMB_VFS_LAYER_OPAQUE},

	/* This indicates the end of the array */
	{SMB_VFS_OP(NULL),				SMB_VFS_OP_NOOP,	SMB_VFS_LAYER_NOOP}
};

NTSTATUS init_module(void)
{
	return smb_register_vfs(SMB_VFS_INTERFACE_VERSION, "example", example_op_tuples);
}
</programlisting>

</sect2>

<sect2>
<title>How the Modules handle per connection data</title>

<para>Each VFS function has as first parameter a pointer to the modules vfs_handle_struct.
</para>

<programlisting format="linespecific">
typedef struct vfs_handle_struct {
	struct vfs_handle_struct  *next, *prev;
	const char *param;
	struct vfs_ops vfs_next;
	struct connection_struct *conn;
	void *data;
	void (*free_data)(void **data);
} vfs_handle_struct;
</programlisting>

<variablelist>

<varlistentry><term>param</term>
<listitem><para>this is the module parameter specified in the <literal>vfs objects</literal> parameter.</para>
<para>e.g. for 'vfs objects = example:test' param would be "test".</para></listitem>
</varlistentry>

<varlistentry><term>vfs_next</term>
<listitem><para>This vfs_ops struct contains the information for calling the next module operations.
Use the SMB_VFS_NEXT_* macros to call a next module operations and
don't access handle-&gt;vfs_next.ops.* directly!</para></listitem>
</varlistentry>

<varlistentry><term>conn</term>
<listitem><para>This is a pointer back to the connection_struct to witch the handle belongs.</para></listitem>
</varlistentry>

<varlistentry><term>data</term>
<listitem><para>This is a pointer for holding module private data.
You can alloc data with connection life time on the handle-&gt;conn-&gt;mem_ctx TALLOC_CTX.
But you can also manage the memory allocation yourself.</para></listitem>
</varlistentry>

<varlistentry><term>free_data</term>
<listitem><para>This is a function pointer to a function that free's the module private data.
If you talloc your private data on the TALLOC_CTX handle-&gt;conn-&gt;mem_ctx,
you can set this function pointer to NULL.</para></listitem>
</varlistentry>

</variablelist>

<para>Some useful MACROS for handle private data.
</para>

<programlisting format="linespecific">
#define SMB_VFS_HANDLE_GET_DATA(handle, datap, type, ret) { \
	if (!(handle)||((datap=(type *)(handle)-&gt;data)==NULL)) { \
		DEBUG(0,("%s() failed to get vfs_handle-&gt;data!\n",FUNCTION_MACRO)); \
		ret; \
	} \
}

#define SMB_VFS_HANDLE_SET_DATA(handle, datap, free_fn, type, ret) { \
	if (!(handle)) { \
		DEBUG(0,("%s() failed to set handle-&gt;data!\n",FUNCTION_MACRO)); \
		ret; \
	} else { \
		if ((handle)-&gt;free_data) { \
			(handle)-&gt;free_data(&amp;(handle)-&gt;data); \
		} \
		(handle)-&gt;data = (void *)datap; \
		(handle)-&gt;free_data = free_fn; \
	} \
}

#define SMB_VFS_HANDLE_FREE_DATA(handle) { \
	if ((handle) &amp;&amp; (handle)-&gt;free_data) { \
		(handle)-&gt;free_data(&amp;(handle)-&gt;data); \
	} \
}
</programlisting>

<para>How SMB_VFS_LAYER_TRANSPARENT functions can call the SMB_VFS_LAYER_OPAQUE functions.</para>

<para>The easiest way to do this is to use the SMB_VFS_OPAQUE_* macros.
</para>

<programlisting format="linespecific">
...
/* File operations */
#define SMB_VFS_OPAQUE_OPEN(conn, fname, flags, mode) \
	((conn)-&gt;vfs_opaque.ops.open(\
	(conn)-&gt;vfs_opaque.handles.open,\
	 (conn), (fname), (flags), (mode)))
#define SMB_VFS_OPAQUE_CLOSE(fsp, fd) \
	((fsp)-&gt;conn-&gt;vfs_opaque.ops.close(\
	(fsp)-&gt;conn-&gt;vfs_opaque.handles.close,\
	 (fsp), (fd)))
#define SMB_VFS_OPAQUE_READ(fsp, fd, data, n) \
	((fsp)-&gt;conn-&gt;vfs_opaque.ops.read(\
	(fsp)-&gt;conn-&gt;vfs_opaque.handles.read,\
	 (fsp), (fd), (data), (n)))
#define SMB_VFS_OPAQUE_WRITE(fsp, fd, data, n) \
	((fsp)-&gt;conn-&gt;vfs_opaque.ops.write(\
	(fsp)-&gt;conn-&gt;vfs_opaque.handles.write,\
	 (fsp), (fd), (data), (n)))
#define SMB_VFS_OPAQUE_LSEEK(fsp, fd, offset, whence) \
	((fsp)-&gt;conn-&gt;vfs_opaque.ops.lseek(\
	(fsp)-&gt;conn-&gt;vfs_opaque.handles.lseek,\
	 (fsp), (fd), (offset), (whence)))
#define SMB_VFS_OPAQUE_SENDFILE(tofd, fsp, fromfd, header, offset, count) \
	((fsp)-&gt;conn-&gt;vfs_opaque.ops.sendfile(\
	(fsp)-&gt;conn-&gt;vfs_opaque.handles.sendfile,\
	 (tofd), (fsp), (fromfd), (header), (offset), (count)))
...
</programlisting>

<para>How SMB_VFS_LAYER_TRANSPARENT functions can call the next modules functions.</para>

<para>The easiest way to do this is to use the SMB_VFS_NEXT_* macros.
</para>

<programlisting format="linespecific">
...
/* File operations */
#define SMB_VFS_NEXT_OPEN(handle, conn, fname, flags, mode) \
	((handle)-&gt;vfs_next.ops.open(\
	(handle)-&gt;vfs_next.handles.open,\
	 (conn), (fname), (flags), (mode)))
#define SMB_VFS_NEXT_CLOSE(handle, fsp, fd) \
	((handle)-&gt;vfs_next.ops.close(\
	(handle)-&gt;vfs_next.handles.close,\
	 (fsp), (fd)))
#define SMB_VFS_NEXT_READ(handle, fsp, fd, data, n) \
	((handle)-&gt;vfs_next.ops.read(\
	(handle)-&gt;vfs_next.handles.read,\
	 (fsp), (fd), (data), (n)))
#define SMB_VFS_NEXT_WRITE(handle, fsp, fd, data, n) \
	((handle)-&gt;vfs_next.ops.write(\
	(handle)-&gt;vfs_next.handles.write,\
	 (fsp), (fd), (data), (n)))
#define SMB_VFS_NEXT_LSEEK(handle, fsp, fd, offset, whence) \
	((handle)-&gt;vfs_next.ops.lseek(\
	(handle)-&gt;vfs_next.handles.lseek,\
	 (fsp), (fd), (offset), (whence)))
#define SMB_VFS_NEXT_SENDFILE(handle, tofd, fsp, fromfd, header, offset, count) \
	((handle)-&gt;vfs_next.ops.sendfile(\
	(handle)-&gt;vfs_next.handles.sendfile,\
	 (tofd), (fsp), (fromfd), (header), (offset), (count)))
...
</programlisting>

</sect2>

</sect1>

<sect1>
<title>Upgrading to the New VFS Interface</title>

<sect2>
<title>Upgrading from 2.2.* and 3.0alpha modules</title>

<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><para>
Add "vfs_handle_struct *handle, " as first parameter to all vfs operation functions.
e.g. example_connect(connection_struct *conn, const char *service, const char *user);
-&gt;   example_connect(vfs_handle_struct *handle, connection_struct *conn, const char *service, const char *user);
</para></listitem>

<listitem><para>
Replace "default_vfs_ops." with "smb_vfs_next_".
e.g. default_vfs_ops.connect(conn, service, user);
-&gt;   smb_vfs_next_connect(conn, service, user);
</para></listitem>

<listitem><para>
Uppercase all "smb_vfs_next_*" functions.
e.g. smb_vfs_next_connect(conn, service, user);
-&gt;   SMB_VFS_NEXT_CONNECT(conn, service, user);
</para></listitem>

<listitem><para>
Add "handle, " as first parameter to all SMB_VFS_NEXT_*() calls.
e.g. SMB_VFS_NEXT_CONNECT(conn, service, user);
-&gt;   SMB_VFS_NEXT_CONNECT(handle, conn, service, user);
</para></listitem>

<listitem><para>
(Only for 2.2.* modules) 
Convert the old struct vfs_ops example_ops to 
a vfs_op_tuple example_op_tuples[] array.
e.g.
<programlisting format="linespecific">
struct vfs_ops example_ops = {
	/* Disk operations */
	example_connect,		/* connect */
	example_disconnect,		/* disconnect */
	NULL,				/* disk free *
	/* Directory operations */
	NULL,				/* opendir */
	NULL,				/* readdir */
	NULL,				/* mkdir */
	NULL,				/* rmdir */
	NULL,				/* closedir */
	/* File operations */
	NULL,				/* open */
	NULL,				/* close */
	NULL,				/* read  */
	NULL,				/* write */
	NULL,				/* lseek */
	NULL,				/* sendfile */
	NULL,				/* rename */
	NULL,				/* fsync */
	example_stat,			/* stat  */
	example_fstat,			/* fstat */
	example_lstat,			/* lstat */
	NULL,				/* unlink */
	NULL,				/* chmod */
	NULL,				/* fchmod */
	NULL,				/* chown */
	NULL,				/* fchown */
	NULL,				/* chdir */
	NULL,				/* getwd */
	NULL,				/* utime */
	NULL,				/* ftruncate */
	NULL,				/* lock */
	NULL,				/* symlink */
	NULL,				/* readlink */
	NULL,				/* link */
	NULL,				/* mknod */
	NULL,				/* realpath */
	NULL,				/* fget_nt_acl */
	NULL,				/* get_nt_acl */
	NULL,				/* fset_nt_acl */
	NULL,				/* set_nt_acl */

	NULL,				/* chmod_acl */
	NULL,				/* fchmod_acl */

	NULL,				/* sys_acl_get_entry */
	NULL,				/* sys_acl_get_tag_type */
	NULL,				/* sys_acl_get_permset */
	NULL,				/* sys_acl_get_qualifier */
	NULL,				/* sys_acl_get_file */
	NULL,				/* sys_acl_get_fd */
	NULL,				/* sys_acl_clear_perms */
	NULL,				/* sys_acl_add_perm */
	NULL,				/* sys_acl_to_text */
	NULL,				/* sys_acl_init */
	NULL,				/* sys_acl_create_entry */
	NULL,				/* sys_acl_set_tag_type */
	NULL,				/* sys_acl_set_qualifier */
	NULL,				/* sys_acl_set_permset */
	NULL,				/* sys_acl_valid */
	NULL,				/* sys_acl_set_file */
	NULL,				/* sys_acl_set_fd */
	NULL,				/* sys_acl_delete_def_file */
	NULL,				/* sys_acl_get_perm */
	NULL,				/* sys_acl_free_text */
	NULL,				/* sys_acl_free_acl */
	NULL				/* sys_acl_free_qualifier */
};
</programlisting>
-&gt;
<programlisting format="linespecific"> 
static vfs_op_tuple example_op_tuples[] = {
	{SMB_VFS_OP(example_connect),	SMB_VFS_OP_CONNECT,	SMB_VFS_LAYER_TRANSPARENT},
	{SMB_VFS_OP(example_disconnect),	SMB_VFS_OP_DISCONNECT,	SMB_VFS_LAYER_TRANSPARENT},
	
	{SMB_VFS_OP(example_fstat), 	SMB_VFS_OP_FSTAT,	SMB_VFS_LAYER_TRANSPARENT},
	{SMB_VFS_OP(example_stat),		SMB_VFS_OP_STAT,	SMB_VFS_LAYER_TRANSPARENT},
	{SMB_VFS_OP(example_lstat), 	SMB_VFS_OP_LSTAT,	SMB_VFS_LAYER_TRANSPARENT},

	{SMB_VFS_OP(NULL),				SMB_VFS_OP_NOOP,	SMB_VFS_LAYER_NOOP}
};
</programlisting>
</para></listitem>

<listitem><para>
Move the example_op_tuples[] array to the end of the file. 
</para></listitem>

<listitem><para>
Add the init_module() function at the end of the file.
e.g.
<programlisting format="linespecific">
NTSTATUS init_module(void)
{
	return smb_register_vfs(SMB_VFS_INTERFACE_VERSION,"example",example_op_tuples);
}
</programlisting>
</para></listitem>

<listitem><para>
Check if your vfs_init() function does more then just prepare the vfs_ops structs or
remember the struct smb_vfs_handle_struct.
<simplelist type="vert">
<member>If NOT you can remove the vfs_init() function.</member>
<member>If YES decide if you want to move the code to the example_connect() operation or to the init_module(). And then remove vfs_init().
  e.g. a debug class registration should go into init_module() and the allocation of private data should go to example_connect().</member>
</simplelist>
</para></listitem>

<listitem><para>
(Only for 3.0alpha* modules) 
Check if your vfs_done() function contains needed code.
<simplelist type="vert">
<member>If NOT you can remove the vfs_done() function.</member>
<member>If YES decide if you can move the code to the example_disconnect() operation. Otherwise register a SMB_EXIT_EVENT with smb_register_exit_event(); (Described in the <link linkend="modules">modules section</link>) And then remove vfs_done(). e.g. the freeing of private data should go to example_disconnect().
</member>
</simplelist>
</para></listitem>

<listitem><para>
Check if you have any global variables left.
Decide if it wouldn't be better to have this data on a connection basis.
<simplelist type="vert">
  <member>If NOT leave them as they are. (e.g. this could be the variable for the private debug class.)</member>
  <member>If YES pack all this data into a struct. You can use handle-&gt;data to point to such a struct on a per connection basis.</member>
</simplelist>

  e.g. if you have such a struct:
<programlisting format="linespecific">    
struct example_privates {
	char *some_string;
	int db_connection;
};
</programlisting>	
first way of doing it:
<programlisting format="linespecific">
static int example_connect(vfs_handle_struct *handle,
	connection_struct *conn, const char *service, 
	const char* user)
{
	struct example_privates *data = NULL;

	/* alloc our private data */
	data = (struct example_privates *)talloc_zero(conn-&gt;mem_ctx, sizeof(struct example_privates));
	if (!data) {
		DEBUG(0,("talloc_zero() failed\n"));
		return -1;
	}

	/* init out private data */
	data-&gt;some_string = talloc_strdup(conn-&gt;mem_ctx,"test");
	if (!data-&gt;some_string) {
		DEBUG(0,("talloc_strdup() failed\n"));
		return -1;
	}

	data-&gt;db_connection = open_db_conn();

	/* and now store the private data pointer in handle-&gt;data
	 * we don't need to specify a free_function here because
	 * we use the connection TALLOC context.
	 * (return -1 if something failed.)
	 */
	VFS_HANDLE_SET_DATA(handle, data, NULL, struct example_privates, return -1);

	return SMB_VFS_NEXT_CONNECT(handle,conn,service,user);
}

static int example_close(vfs_handle_struct *handle, files_struct *fsp, int fd)
{
	struct example_privates *data = NULL;
	
	/* get the pointer to our private data
	 * return -1 if something failed
	 */
	SMB_VFS_HANDLE_GET_DATA(handle, data, struct example_privates, return -1);
	
	/* do something here...*/
	DEBUG(0,("some_string: %s\n",data-&gt;some_string));
	
	return SMB_VFS_NEXT_CLOSE(handle, fsp, fd);
}
</programlisting>
second way of doing it:
<programlisting format="linespecific">
static void free_example_privates(void **datap)
{
	struct example_privates *data = (struct example_privates *)*datap;
	
	SAFE_FREE(data-&gt;some_string);
	SAFE_FREE(data);
	
	*datap = NULL;
	
	return;
}

static int example_connect(vfs_handle_struct *handle, 
	connection_struct *conn, const char *service, 
	const char* user)
{
	struct example_privates *data = NULL;

	/* alloc our private data */
	data = (struct example_privates *)malloc(sizeof(struct example_privates));
	if (!data) {
		DEBUG(0,("malloc() failed\n"));
		return -1;
	}

	/* init out private data */
	data-&gt;some_string = strdup("test");
	if (!data-&gt;some_string) {
		DEBUG(0,("strdup() failed\n"));
		return -1;
	}

	data-&gt;db_connection = open_db_conn();

	/* and now store the private data pointer in handle-&gt;data
	 * we need to specify a free_function because we used malloc() and strdup().
	 * (return -1 if something failed.)
	 */
	SMB_VFS_HANDLE_SET_DATA(handle, data, free_example_privates, struct example_privates, return -1);

	return SMB_VFS_NEXT_CONNECT(handle,conn,service,user);
}

static int example_close(vfs_handle_struct *handle, files_struct *fsp, int fd)
{
	struct example_privates *data = NULL;
	
	/* get the pointer to our private data
	 * return -1 if something failed
	 */
	SMB_VFS_HANDLE_GET_DATA(handle, data, struct example_privates, return -1);
	
	/* do something here...*/
	DEBUG(0,("some_string: %s\n",data-&gt;some_string));
	
	return SMB_VFS_NEXT_CLOSE(handle, fsp, fd);
}
</programlisting>
</para></listitem>

<listitem><para>
To make it easy to build 3rd party modules it would be useful to provide
configure.in, (configure), install.sh and Makefile.in with the module.
(Take a look at the example in <filename moreinfo="none">examples/VFS</filename>.)
</para>

<para>
The configure script accepts <option>--with-samba-source</option> to specify 
the path to the samba source tree.
It also accept <option>--enable-developer</option> which lets the compiler 
give you more warnings.  
</para>

<para>
The idea is that you can extend this 
<filename moreinfo="none">configure.in</filename> and <filename moreinfo="none">Makefile.in</filename> scripts
for your module.
</para></listitem>

<listitem><para>
Compiling &amp; Testing...
<simplelist type="vert">
<member><userinput moreinfo="none">./configure <option>--enable-developer</option></userinput> ...</member>
<member><userinput moreinfo="none">make</userinput></member>
<member>Try to fix all compiler warnings</member>
<member><userinput moreinfo="none">make</userinput></member>
<member>Testing, Testing, Testing ...</member>
</simplelist>
</para></listitem>
</orderedlist>
</sect2>

</sect1>

<sect1>
<title>Some Notes</title>

<sect2>
<title>Implement TRANSPARENT functions</title>

<para>
Avoid writing functions like this:

<programlisting format="linespecific">
static int example_close(vfs_handle_struct *handle, files_struct *fsp, int fd)
{
	return SMB_VFS_NEXT_CLOSE(handle, fsp, fd);
}
</programlisting>

Overload only the functions you really need to!
</para>

</sect2>

<sect2>
<title>Implement OPAQUE functions</title>

<para>
If you want to just implement a better version of a 
default samba opaque function
(e.g. like a disk_free() function for a special filesystem) 
it's ok to just overload that specific function.
</para>

<para>
If you want to implement a database filesystem or
something different from a posix filesystem.
Make sure that you overload every vfs operation!!!
</para>
<para>
Functions your FS does not support should be overloaded by something like this:
e.g. for a readonly filesystem.
</para>

<programlisting format="linespecific">
static int example_rename(vfs_handle_struct *handle, connection_struct *conn,
			char *oldname, char *newname)
{
	DEBUG(10,("function rename() not allowed on vfs 'example'\n"));
	errno = ENOSYS;
	return -1;
}
</programlisting>

</sect2>

</sect1>

</chapter>
	<chapter id="parsing">
<chapterinfo>
	<author>
		<firstname>Chris</firstname><surname>Hertel</surname>
	</author>
	<pubdate>November 1997</pubdate>
</chapterinfo>

<title>The smb.conf file</title>

<sect1>
<title>Lexical Analysis</title>

<para>
Basically, the file is processed on a line by line basis.  There are
four types of lines that are recognized by the lexical analyzer
(params.c):
</para>

<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><para>
Blank lines - Lines containing only whitespace.
</para></listitem>
<listitem><para>
Comment lines - Lines beginning with either a semi-colon or a
pound sign (';' or '#').
</para></listitem>
<listitem><para>
Section header lines - Lines beginning with an open square bracket ('[').
</para></listitem>
<listitem><para>
Parameter lines - Lines beginning with any other character.
(The default line type.)
</para></listitem>
</orderedlist>

<para>
The first two are handled exclusively by the lexical analyzer, which
ignores them.  The latter two line types are scanned for
</para>

<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><para>
  - Section names
</para></listitem>
<listitem><para>
  - Parameter names
</para></listitem>
<listitem><para>
  - Parameter values
</para></listitem>
</orderedlist>

<para>
These are the only tokens passed to the parameter loader
(loadparm.c).  Parameter names and values are divided from one
another by an equal sign: '='.
</para>

<sect2>
<title>Handling of Whitespace</title>

<para>
Whitespace is defined as all characters recognized by the isspace()
function (see ctype(3C)) except for the newline character ('\n')
The newline is excluded because it identifies the end of the line.
</para>

<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><para>
The lexical analyzer scans past white space at the beginning of a line.
</para></listitem>

<listitem><para>
Section and parameter names may contain internal white space.  All
whitespace within a name is compressed to a single space character. 
</para></listitem>

<listitem><para>
Internal whitespace within a parameter value is kept verbatim with 
the exception of carriage return characters ('\r'), all of which
are removed.
</para></listitem>

<listitem><para>
Leading and trailing whitespace is removed from names and values.
</para></listitem>

</orderedlist>

</sect2>

<sect2>
<title>Handling of Line Continuation</title>

<para>
Long section header and parameter lines may be extended across
multiple lines by use of the backslash character ('\\').  Line
continuation is ignored for blank and comment lines.
</para>

<para>
If the last (non-whitespace) character within a section header or on
a parameter line is a backslash, then the next line will be
(logically) concatonated with the current line by the lexical
analyzer.  For example:
</para>

<para><programlisting format="linespecific">
	param name = parameter value string \
	with line continuation.
</programlisting></para>

<para>Would be read as</para>

<para><programlisting format="linespecific">
    param name = parameter value string     with line continuation.
</programlisting></para>

<para>
Note that there are five spaces following the word 'string',
representing the one space between 'string' and '\\' in the top
line, plus the four preceeding the word 'with' in the second line.
(Yes, I'm counting the indentation.)
</para>

<para>
Line continuation characters are ignored on blank lines and at the end
of comments.  They are *only* recognized within section and parameter
lines.
</para>

</sect2>

<sect2>
<title>Line Continuation Quirks</title>

<para>Note the following example:</para>

<para><programlisting format="linespecific">
	param name = parameter value string \
    \
    with line continuation.
</programlisting></para>

<para>
The middle line is *not* parsed as a blank line because it is first
concatonated with the top line.  The result is
</para>

<para><programlisting format="linespecific">
param name = parameter value string         with line continuation.
</programlisting></para>

<para>The same is true for comment lines.</para>

<para><programlisting format="linespecific">
	param name = parameter value string \
	; comment \
    with a comment.
</programlisting></para>

<para>This becomes:</para>

<para><programlisting format="linespecific">
param name = parameter value string     ; comment     with a comment.
</programlisting></para>

<para>
On a section header line, the closing bracket (']') is considered a
terminating character, and the rest of the line is ignored.  The lines
</para>

<para><programlisting format="linespecific">
	[ section   name ] garbage \
    param  name  = value
</programlisting></para>

<para>are read as</para>

<para><programlisting format="linespecific">
	[section name]
    param name = value
</programlisting></para>

</sect2>
</sect1>

<sect1>
<title>Syntax</title>

<para>The syntax of the smb.conf file is as follows:</para>

<para><programlisting format="linespecific">
  &lt;file&gt;            :==  { &lt;section&gt; } EOF
  &lt;section&gt;         :==  &lt;section header&gt; { &lt;parameter line&gt; }
  &lt;section header&gt;  :==  '[' NAME ']'
  &lt;parameter line&gt;  :==  NAME '=' VALUE NL
</programlisting></para>

<para>Basically, this means that</para>

<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><para>
	a file is made up of zero or more sections, and is terminated by
	an EOF (we knew that).
</para></listitem>

<listitem><para>
	A section is made up of a section header followed by zero or more
	parameter lines.
</para></listitem>

<listitem><para>
	A section header is identified by an opening bracket and
	terminated by the closing bracket.  The enclosed NAME identifies
	the section.
</para></listitem>

<listitem><para>
	A parameter line is divided into a NAME and a VALUE.  The *first*
	equal sign on the line separates the NAME from the VALUE.  The
	VALUE is terminated by a newline character (NL = '\n').
</para></listitem>

</orderedlist>

<sect2>
<title>About params.c</title>

<para>
The parsing of the config file is a bit unusual if you are used to
lex, yacc, bison, etc.  Both lexical analysis (scanning) and parsing
are performed by params.c.  Values are loaded via callbacks to
loadparm.c.
</para>
</sect2>
</sect1>
</chapter>
	<chapter id="wins">
<chapterinfo>
	<author>
		<firstname>Gerald</firstname><surname>Carter</surname>
	</author>
	<pubdate>October 2002</pubdate>
</chapterinfo>


<title>Samba WINS Internals</title>


<sect1>
<title>WINS Failover</title>


<para>
The current Samba codebase possesses the capability to use groups of WINS
servers that share a common namespace for NetBIOS name registration and 
resolution.  The formal parameter syntax is
</para>

<para><programlisting format="linespecific">
	WINS_SERVER_PARAM 	= SERVER [ SEPARATOR SERVER_LIST ]
	WINS_SERVER_PARAM 	= "wins server"
	SERVER 			= ADDR[:TAG]
	ADDR 			= ip_addr | fqdn
	TAG 			= string
	SEPARATOR		= comma | \s+
	SERVER_LIST		= SERVER [ SEPARATOR SERVER_LIST ]
</programlisting></para>

<para>
A simple example of a valid wins server setting is
</para>

<para><programlisting format="linespecific">
[global]
	wins server = 192.168.1.2 192.168.1.3
</programlisting></para>

<para>
In the event that no TAG is defined in for a SERVER in the list, smbd assigns a default
TAG of "*".  A TAG is used to group servers of a shared NetBIOS namespace together.  Upon
startup, nmbd will attempt to register the netbios name value with one server in each
tagged group.
</para>

<para>
An example using tags to group WINS servers together is show here.  Note that the use of
interface names in the tags is only by convention and is not a technical requirement.
</para>


<para><programlisting format="linespecific">
[global]
	wins server = 192.168.1.2:eth0 192.168.1.3:eth0 192.168.2.2:eth1
</programlisting></para>

<para>
Using this configuration, nmbd would attempt to register the server's NetBIOS name 
with one WINS server in each group.  Because the "eth0" group has two servers, the 
second server would only be used when a registration (or resolution) request to 
the first server in that group timed out.
</para>

<para>
NetBIOS name resolution follows a similar pattern as name registration.  When resolving 
a NetBIOS name via WINS, smbd and other Samba programs will attempt to query a single WINS 
server in a tagged group until either a positive response is obtained at least once or 
until a server from every tagged group has responded negatively to the name query request.
If a timeout occurs when querying a specific WINS server, that server is marked as down to 
prevent further timeouts and the next server in the WINS group is contacted.  Once marked as 
dead, Samba will not attempt to contact that server for name registration/resolution queries 
for a period of 10 minutes.
</para>

</sect1>
</chapter>
	<chapter id="pwencrypt">


<chapterinfo>
	<author>
		<firstname>Jeremy</firstname><surname>Allison</surname>
		<affiliation>
			<orgname>Samba Team</orgname>
			<address format="linespecific">
				<email>samba@samba.org</email>
			</address>
		</affiliation>
	</author>

	<pubdate>19 Apr 1999</pubdate>
</chapterinfo>
	
<title>LanMan and NT Password Encryption</title>

<sect1>
	<title>Introduction</title>
	
	<para>With the development of LanManager and Windows NT 
	compatible password encryption for Samba, it is now able 
	to validate user connections in exactly the same way as 
	a LanManager or Windows NT server.</para>

	<para>This document describes how the SMB password encryption 
	algorithm works and what issues there are in choosing whether 
	you want to use it. You should read it carefully, especially 
	the part about security and the "PROS and CONS" section.</para>
	
</sect1>

<sect1>
	<title>How does it work?</title>

	<para>LanManager encryption is somewhat similar to UNIX 
	password encryption. The server uses a file containing a 
	hashed value of a user's password.  This is created by taking 
	the user's plaintext password, capitalising it, and either 
	truncating to 14 bytes or padding to 14 bytes with null bytes. 
	This 14 byte value is used as two 56 bit DES keys to encrypt 
	a 'magic' eight byte value, forming a 16 byte value which is 
	stored by the server and client. Let this value be known as 
	the "hashed password".</para>
	
	<para>Windows NT encryption is a higher quality mechanism, 
	consisting of doing an MD4 hash on a Unicode version of the user's 
	password. This also produces a 16 byte hash value that is 
	non-reversible.</para>

	<para>When a client (LanManager, Windows for WorkGroups, Windows 
	95 or Windows NT) wishes to mount a Samba drive (or use a Samba 
	resource), it first requests a connection and negotiates the 
	protocol that the client and server will use. In the reply to this 
	request the Samba server generates and appends an 8 byte, random 
	value - this is stored in the Samba server after the reply is sent 
	and is known as the "challenge".  The challenge is different for 
	every client connection.</para>

	<para>The client then uses the hashed password (16 byte values 
	described above), appended with 5 null bytes, as three 56 bit 
	DES keys, each of which is used to encrypt the challenge 8 byte 
	value, forming a 24 byte value known as the "response".</para>

	<para>In the SMB call SMBsessionsetupX (when user level security 
	is selected) or the call SMBtconX (when share level security is 
	selected), the 24 byte response is returned by the client to the 
	Samba server.  For Windows NT protocol levels the above calculation 
	is done on both hashes of the user's password and both responses are 
	returned in the SMB call, giving two 24 byte values.</para>

	<para>The Samba server then reproduces the above calculation, using 
	its own stored value of the 16 byte hashed password (read from the 
	<filename moreinfo="none">smbpasswd</filename> file - described later) and the challenge 
	value that it kept from the negotiate protocol reply. It then checks 
	to see if the 24 byte value it calculates matches the 24 byte value 
	returned to it from the client.</para>

	<para>If these values match exactly, then the client knew the 
	correct password (or the 16 byte hashed value - see security note 
	below) and is thus allowed access. If not, then the client did not 
	know the correct password and is denied access.</para>

	<para>Note that the Samba server never knows or stores the cleartext 
	of the user's password - just the 16 byte hashed values derived from 
	it. Also note that the cleartext password or 16 byte hashed values 
	are never transmitted over the network - thus increasing security.</para>
</sect1>

<sect1>
	<title>The smbpasswd file</title>
	<anchor id="SMBPASSWDFILEFORMAT"/>
	<para>In order for Samba to participate in the above protocol 
	it must be able to look up the 16 byte hashed values given a user name.
	Unfortunately, as the UNIX password value is also a one way hash
	function (ie. it is impossible to retrieve the cleartext of the user's
	password given the UNIX hash of it), a separate password file
	containing this 16 byte value must be kept. To minimise problems with
	these two password files, getting out of sync, the UNIX <filename moreinfo="none">
	/etc/passwd</filename> and the <filename moreinfo="none">smbpasswd</filename> file, 
	a utility, <literal>mksmbpasswd.sh</literal>, is provided to generate
	a smbpasswd file from a UNIX <filename moreinfo="none">/etc/passwd</filename> file.
	</para>


	<para>To generate the smbpasswd file from your <filename moreinfo="none">/etc/passwd
	</filename> file use the following command:</para>
	
	<para><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">cat /etc/passwd | mksmbpasswd.sh
	&gt; /usr/local/samba/private/smbpasswd</userinput></para>
	
	<para>If you are running on a system that uses NIS, use</para>

	<para><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">ypcat passwd | mksmbpasswd.sh
	&gt; /usr/local/samba/private/smbpasswd</userinput></para>
	
	<para>The <literal>mksmbpasswd.sh</literal> program is found in 
	the Samba source directory. By default, the smbpasswd file is 
	stored in :</para>

	<para><filename moreinfo="none">/usr/local/samba/private/smbpasswd</filename></para>

	<para>The owner of the <filename moreinfo="none">/usr/local/samba/private/</filename> 
	directory should be set to root, and the permissions on it should 
	be set to 0500 (<literal>chmod 500 /usr/local/samba/private</literal>).
	</para>

	<para>Likewise, the smbpasswd file inside the private directory should 
	be owned by root and the permissions on is should be set to 0600
	(<literal>chmod 600 smbpasswd</literal>).</para>


	<para>The format of the smbpasswd file is (The line has been 
	wrapped here. It should appear as one entry per line in 
	your smbpasswd file.)</para>
	
	<para><programlisting format="linespecific">
username:uid:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX:
	[Account type]:LCT-&lt;last-change-time&gt;:Long name
	</programlisting></para>
	
	<para>Although only the <replaceable>username</replaceable>, 
	<replaceable>uid</replaceable>, <replaceable>
	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</replaceable>,
	[<replaceable>Account type</replaceable>] and <replaceable>
	last-change-time</replaceable> sections are significant 
	and are looked at in the Samba code.</para>

	<para>It is <emphasis>VITALLY</emphasis> important that there by 32 
	'X' characters between the two ':' characters in the XXX sections - 
	the smbpasswd and Samba code will fail to validate any entries that 
	do not have 32 characters  between ':' characters. The first XXX 
	section is for the Lanman password hash, the second is for the 
	Windows NT version.</para>

	<para>When the password file is created all users have password entries
	consisting of 32 'X' characters. By default this disallows any access
	as this user. When a user has a password set, the 'X' characters change
	to 32 ascii hexadecimal digits (0-9, A-F). These are an ascii
	representation of the 16 byte hashed value of a user's password.</para>

	<para>To set a user to have no password (not recommended), edit the file
	using vi, and replace the first 11 characters with the ascii text
	<constant>"NO PASSWORD"</constant> (minus the quotes).</para>

	<para>For example, to clear the password for user bob, his smbpasswd file 
	entry would look like :</para>

	<para><programlisting format="linespecific">
bob:100:NO PASSWORDXXXXXXXXXXXXXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX:
	[U          ]:LCT-00000000:Bob's full name:/bobhome:/bobshell
	</programlisting></para>
	
	<para>If you are allowing users to use the smbpasswd command to set 
	their own passwords, you may want to give users NO PASSWORD initially 
	so they do not have to enter a previous password when changing to their 
	new password (not recommended). In order for you to allow this the
	<literal>smbpasswd</literal> program must be able to connect to the 
	<literal>smbd</literal> daemon as that user with no password. Enable this 
	by adding the line :</para>

	<para><literal>null passwords = yes</literal></para>
	
	<para>to the [global] section of the smb.conf file (this is why 
	the above scenario is not recommended). Preferably, allocate your
	users a default password to begin with, so you do not have
	to enable this on your server.</para>

	<para><emphasis>Note : </emphasis>This file should be protected very 
	carefully. Anyone with access to this file can (with enough knowledge of 
	the protocols) gain access to your SMB server. The file is thus more 
	sensitive than a normal unix <filename moreinfo="none">/etc/passwd</filename> file.</para>
</sect1>

</chapter>

</part>

<part>
	<title>Debugging and tracing</title>

	<chapter id="tracing">
<chapterinfo>
	<author>
		<firstname>Andrew</firstname><surname>Tridgell</surname>
		<affiliation>
			<orgname>Samba Team</orgname>
		</affiliation>
	</author>
</chapterinfo>

<title>Tracing samba system calls</title>

<para>
This file describes how to do a system call trace on Samba to work out
what its doing wrong. This is not for the faint of heart, but if you
are reading this then you are probably desperate.
</para>

<para>
Actually its not as bad as the the above makes it sound, just don't
expect the output to be very pretty :-)
</para>

<para>
Ok, down to business. One of the big advantages of unix systems is
that they nearly all come with a system trace utility that allows you
to monitor all system calls that a program is making. This is
extremely using for debugging and also helps when trying to work out
why something is slower than you expect. You can use system tracing
without any special compilation options. 
</para>

<para>
The system trace utility is called different things on different
systems. On Linux systems its called strace. Under SunOS 4 its called
trace. Under SVR4 style systems (including solaris) its called
truss. Under many BSD systems its called ktrace. 
</para>

<para>
The first thing you should do is read the man page for your native
system call tracer. In the discussion below I'll assume its called
strace as strace is the only portable system tracer (its available for
free for many unix types) and its also got some of the nicest
features.
</para>

<para>
Next, try using strace on some simple commands. For example, <literal>strace
ls</literal> or <literal>strace echo hello</literal>.
</para>

<para> 
You'll notice that it produces a LOT of output. It is showing you the
arguments to every system call that the program makes and the
result. Very little happens in a program without a system call so you
get lots of output. You'll also find that it produces a lot of
"preamble" stuff showing the loading of shared libraries etc. Ignore
this (unless its going wrong!)
</para>

<para>
For example, the only line that really matters in the <literal>strace echo
hello</literal> output is:
</para>

<para><programlisting format="linespecific">
write(1, "hello\n", 6)                  = 6
</programlisting></para>

<para>all the rest is just setting up to run the program.</para>

<para>
Ok, now you're familiar with strace. To use it on Samba you need to
strace the running smbd daemon. The way I tend ot use it is to first
login from my Windows PC to the Samba server, then use smbstatus to
find which process ID that client is attached to, then as root I do
<literal>strace -p PID</literal> to attach to that process. I normally redirect the
stderr output from this command to a file for later perusal. For
example, if I'm using a csh style shell:
</para>

<para><literal>strace -f -p 3872 &gt;&amp; strace.out</literal></para>

<para>or with a sh style shell:</para>

<para><literal>strace -f -p 3872 &gt; strace.out 2&gt;&amp;1</literal></para>

<para>
Note the "-f" option. This is only available on some systems, and
allows you to trace not just the current process, but any children it
forks. This is great for finding printing problems caused by the
"print command" being wrong.
</para>

<para>
Once you are attached you then can do whatever it is on the client
that is causing problems and you will capture all the system calls
that smbd makes. 
</para>

<para>
So how do you interpret the results? Generally I search through the
output for strings that I know will appear when the problem
happens. For example, if I am having touble with permissions on a file
I would search for that files name in the strace output and look at
the surrounding lines. Another trick is to match up file descriptor
numbers and "follow" what happens to an open file until it is closed.
</para>

<para>
Beyond this you will have to use your initiative. To give you an idea
of what you are looking for here is a piece of strace output that
shows that <filename moreinfo="none">/dev/null</filename> is not world writeable, which
causes printing to fail with Samba:
</para>

<para><programlisting format="linespecific">
[pid 28268] open("/dev/null", O_RDWR)   = -1 EACCES (Permission denied)
[pid 28268] open("/dev/null", O_WRONLY) = -1 EACCES (Permission denied)
</programlisting></para>

<para>
The process is trying to first open <filename moreinfo="none">/dev/null</filename> read-write 
then read-only. Both fail. This means <filename moreinfo="none">/dev/null</filename> has 
incorrect permissions.
</para>

</chapter>
	<chapter id="devprinting">
<chapterinfo>
	<author>
		<firstname>Gerald</firstname><surname>Carter</surname>
	</author>
	<pubdate>October 2002</pubdate>
</chapterinfo>


<title>Samba Printing Internals</title>


<sect1>
<title>Abstract</title>
<para>
The purpose of this document is to provide some insight into
Samba's printing functionality and also to describe the semantics
of certain features of Windows client printing.
</para>
</sect1>



<sect1>
<title>
Printing Interface to Various Back ends
</title>

<para>
Samba uses a table of function pointers to seven functions.  The
function prototypes are defined in the <varname>printif</varname> structure declared
in <filename moreinfo="none">printing.h</filename>.
</para>

<itemizedlist>
	<listitem><para>retrieve the contents of a print queue</para></listitem>
	<listitem><para>pause the print queue</para></listitem>
	<listitem><para>resume a paused print queue</para></listitem>
	<listitem><para>delete a job from the queue</para></listitem>
	<listitem><para>pause a job in the print queue</para></listitem>
	<listitem><para>result a paused print job in the queue</para></listitem>
	<listitem><para>submit a job to the print queue</para></listitem>
</itemizedlist>

<para>
Currently there are only two printing back end implementations
defined.
</para>

<itemizedlist>
	<listitem><para>a generic set of functions for working with standard UNIX
	printing subsystems</para></listitem>

	<listitem><para>a set of CUPS specific functions (this is only enabled if
	the CUPS libraries were located at compile time).</para></listitem>
</itemizedlist>

</sect1>




<sect1>
<title>
Print Queue TDB's
</title>


<para>
Samba provides periodic caching of the output from the "lpq command"
for performance reasons.  This cache time is configurable in seconds.
Obviously the longer the cache time the less often smbd will be
required to exec a copy of lpq.  However, the accuracy of the print
queue contents displayed to clients will be diminished as well.
</para>

<para>
The list of currently opened print queue TDB's can be found
be examining the list of tdb_print_db structures ( see print_db_head
in printing.c ). A queue TDB is opened using the wrapper function
printing.c:get_print_db_byname().  The function ensures that smbd
does not open more than MAX_PRINT_DBS_OPEN in an effort to prevent
a large print server from exhausting all available file descriptors.
If the number of open queue TDB's exceeds the MAX_PRINT_DBS_OPEN
limit, smbd falls back to a most recently used algorithm for maintaining
a list of open TDB's.
</para>

<para>
There are two ways in which a a print job can be entered into
a print queue's TDB.  The first is to submit the job from a Windows
client which will insert the job information directly into the TDB.
The second method is to have the print job picked up by executing the
"lpq command".
</para>

<para><programlisting format="linespecific">
/* included from printing.h */
struct printjob {
	pid_t pid; /* which process launched the job */
	int sysjob; /* the system (lp) job number */
	int fd; /* file descriptor of open file if open */
	time_t starttime; /* when the job started spooling */
	int status; /* the status of this job */
	size_t size; /* the size of the job so far */
	int page_count;	/* then number of pages so far */
	BOOL spooled; /* has it been sent to the spooler yet? */
	BOOL smbjob; /* set if the job is a SMB job */
	fstring filename; /* the filename used to spool the file */
	fstring jobname; /* the job name given to us by the client */
	fstring user; /* the user who started the job */
	fstring queuename; /* service number of printer for this job */
	NT_DEVICEMODE *nt_devmode;
};
</programlisting></para>

<para>
The current manifestation of the printjob structure contains a field
for the UNIX job id returned from the "lpq command" and a Windows job
ID (32-bit bounded by PRINT_MAX_JOBID).  When a print job is returned
by the "lpq command" that does not match an existing job in the queue's
TDB, a 32-bit job ID above the &lt;*vance doesn't know what word is missing here*&gt; is generating by adding UNIX_JOB_START to
the id reported by lpq.
</para>

<para>
In order to match a 32-bit Windows jobid onto a 16-bit lanman print job
id, smbd uses an in memory TDB to match the former to a number appropriate
for old lanman clients.
</para>

<para>
When updating a print queue, smbd will perform the following
steps ( refer to <filename moreinfo="none">print.c:print_queue_update()</filename> ):
</para>

<orderedlist inheritnum="ignore" continuation="restarts">
	<listitem><para>Check to see if another smbd is currently in 
	the process of updating the queue contents by checking the pid 
	stored in <constant>LOCK/<replaceable>printer_name</replaceable></constant>.  
	If so, then do not update the TDB.</para></listitem>
	
	<listitem><para>Lock the mutex entry in the TDB and store our own pid.
	Check that this succeeded, else fail.</para></listitem>

	<listitem><para>Store the updated time stamp for the new cache
	listing</para></listitem>

	<listitem><para>Retrieve the queue listing via "lpq command"</para></listitem>

	<listitem><para><programlisting format="linespecific">
	foreach job in the queue
     	{
		if the job is a UNIX job, create a new entry;
		if the job has a Windows based jobid, then
		{
			Lookup the record by the jobid;
			if the lookup failed, then
				treat it as a UNIX job;
			else
				update the job status only
		}
	}</programlisting></para></listitem>

	<listitem><para>Delete any jobs in the TDB that are not
	in the in the lpq listing</para></listitem>

	<listitem><para>Store the print queue status in the TDB</para></listitem>
	
	<listitem><para>update the cache time stamp again</para></listitem>
	
</orderedlist>

<para>
Note that it is the contents of this TDB that is returned to Windows
clients and not the actual listing from the "lpq command".
</para>

<para>
The NT_DEVICEMODE stored as part of the printjob structure is used to
store a pointer to a non-default DeviceMode associated with the print
job.  The pointer will be non-null when the client included a Device
Mode in the OpenPrinterEx() call and subsequently submitted a job for
printing on that same handle.  If the client did not include a Device
Mode in the OpenPrinterEx() request, the nt_devmode field is NULL
and the job has the printer's device mode associated with it by default.
</para>

<para>
Only non-default Device Mode are stored with print jobs in the print
queue TDB.  Otherwise, the Device Mode is obtained from the printer
object when the client issues a GetJob(level == 2) request.
</para>

</sect1>




<sect1>
<title>
ChangeID and Client Caching of Printer Information
</title>

<para>
[To be filled in later]
</para>
</sect1>



<sect1>
<title>
Windows NT/2K Printer Change Notify
</title>

<para>
When working with Windows NT+ clients, it is possible for a
print server to use RPC to send asynchronous change notification
events to clients for certain printer and print job attributes.
This can be useful when the client needs to know that a new
job has been added to the queue for a given printer or that the
driver for a printer has been changed.  Note that this is done
entirely orthogonal to cache updates based on a new ChangeID for
a printer object.
</para>

<para>
The basic set of RPC's used to implement change notification are
</para>

<itemizedlist>
	<listitem><para>RemoteFindFirstPrinterChangeNotifyEx ( RFFPCN )</para></listitem>
	<listitem><para>RemoteFindNextPrinterChangeNotifyEx ( RFNPCN )</para></listitem>
	<listitem><para>FindClosePrinterChangeNotify( FCPCN )</para></listitem>
	<listitem><para>ReplyOpenPrinter</para></listitem>
	<listitem><para>ReplyClosePrinter</para></listitem>
	<listitem><para>RouteRefreshPrinterChangeNotify ( RRPCN )</para></listitem>
</itemizedlist>

<para>
One additional RPC is available to a server, but is never used by the
Windows spooler service:
</para>

<itemizedlist>
	<listitem><para>RouteReplyPrinter()</para></listitem>
</itemizedlist>

<para>
The opnum for all of these RPC's are defined in include/rpc_spoolss.h
</para>

<para>
Windows NT print servers use a bizarre method of sending print
notification event to clients.  The process of registering a new change
notification handle is as follows.  The 'C' is for client and the
'S' is for server.  All error conditions have been eliminated.
</para>

<para><programlisting format="linespecific">
C:	Obtain handle to printer or to the printer
	server via the standard OpenPrinterEx() call.
S:	Respond with a valid handle to object

C:	Send a RFFPCN request with the previously obtained
	handle with either (a) set of flags for change events
	to monitor, or (b) a PRINTER_NOTIFY_OPTIONS structure
	containing the event information to monitor.  The windows
	spooler has only been observed to use (b).
S:	The &lt;* another missing word*&gt; opens a new TCP session to the client (thus requiring
	all print clients to be CIFS servers as well) and sends
	a ReplyOpenPrinter() request to the client.
C:	The client responds with a printer handle that can be used to
	send event notification messages.
S:	The server replies success to the RFFPCN request.

C:	The windows spooler follows the RFFPCN with a RFNPCN
	request to fetch the current values of all monitored
	attributes.
S:	The server replies with an array SPOOL_NOTIFY_INFO_DATA
	structures (contained in a SPOOL_NOTIFY_INFO structure).

C:	If the change notification handle is ever released by the
	client via a FCPCN request, the server sends a ReplyClosePrinter()
	request back to the client first.  However a request of this
	nature from the client is often an indication that the previous
	notification event was not marshalled correctly by the server
	or a piece of data was wrong.
S:	The server closes the internal change notification handle
	(POLICY_HND) and does not send any further change notification
	events to the client for that printer or job.
</programlisting></para>

<para>
The current list of notification events supported by Samba can be
found by examining the internal tables in srv_spoolss_nt.c
</para>

<itemizedlist>
	<listitem><para>printer_notify_table[]</para></listitem>
	<listitem><para>job_notify_table[]</para></listitem>
</itemizedlist>

<para>
When an event occurs that could be monitored, smbd sends a message
to itself about the change.  The list of events to be transmitted
are queued by the smbd process sending the message to prevent an
overload of TDB usage and the internal message is sent during smbd's
idle loop (refer to printing/notify.c and the functions
send_spoolss_notify2_msg() and print_notify_send_messages() ).
</para>

<para>
The decision of whether or not the change is to be sent to connected
clients is made by the routine which actually sends the notification.
( refer to srv_spoolss_nt.c:recieve_notify2_message() ).
</para>

<para>
Because it possible to receive a listing of multiple changes for
multiple printers, the notification events must be split into
categories by the printer name.  This makes it possible to group
multiple change events to be sent in a single RPC according to the
printer handle obtained via a ReplyOpenPrinter().
</para>

<para>
The actual change notification is performed using the RRPCN request
RPC.  This packet contains
</para>


<itemizedlist>
	
<listitem><para>the printer handle registered with the
client's spooler on which the change occurred</para></listitem>

<listitem><para>The change_low value which was sent as part
of the last RFNPCN request from the client</para></listitem>

<listitem><para>The SPOOL_NOTIFY_INFO container with the event
information</para></listitem>

</itemizedlist>

<para>
A <varname>SPOOL_NOTIFY_INFO</varname> contains:
</para>

<itemizedlist>

<listitem><para>the version and flags field are predefined
and should not be changed</para></listitem>

<listitem><para>The count field is the number of entries
in the SPOOL_NOTIFY_INFO_DATA array</para></listitem>

</itemizedlist>

<para>
The <varname>SPOOL_NOTIFY_INFO_DATA</varname> entries contain:
</para>

<itemizedlist>

<listitem><para>The type defines whether or not this event
is for a printer or a print job</para></listitem>

<listitem><para>The field is the flag identifying the event</para></listitem>

<listitem><para>the notify_data union contains the new valuie of the
attribute</para></listitem>

<listitem><para>The enc_type defines the size of the structure for marshalling
and unmarshalling</para></listitem>

<listitem><para>(a) the id must be 0 for a printer event on a printer handle.
(b) the id must be the job id for an event on a printer job
(c) the id must be the matching number of the printer index used
in the response packet to the RFNPCN when using a print server
handle for notification.  Samba currently uses the snum of
the printer for this which can break if the list of services
has been modified since the notification handle was registered.</para></listitem>

<listitem><para>The size is either (a) the string length in UNICODE for strings,
(b) the size in bytes of the security descriptor, or (c) 0 for
data values.</para></listitem>

</itemizedlist>

</sect1>
</chapter>
</part>

<part><title>Appendices</title>
	<chapter id="Packaging">
<chapterinfo>
	<author>
		<firstname>Jelmer</firstname><surname>Vernooij</surname>
	</author>
</chapterinfo>

<title>Notes to packagers</title>

<sect1>
<title>Versioning</title>

<para>
Please, please update the version number in <filename moreinfo="none">source/include/version.h</filename> to include the
versioning of your package. This makes it easier to distinguish standard samba builds from custom-build samba
builds (distributions often patch packages). For example, a good version would be:
</para>

<para><programlisting format="linespecific">
Version 2.999+3.0.alpha21-5 for Debian
</programlisting></para>

</sect1>

<sect1>
<title>Modules</title>

<para>
Samba3 has support for building parts of samba as plugins. This makes it possible to, for example,
put ldap or mysql support in a separate package, thus making it possible to have a normal samba package not
depending on ldap or mysql. To build as much parts of samba as a plugin, run:
</para>

<para>
The option <literal moreinfo="none">--with-shared-modules</literal> is maintained to support specific modules such as
idmap_XXX and vfs_XXX. For example, <literal moreinfo="none">--with-shared-modules=idmap_ad</literal>. Use of this parameter
to the <literal>configure</literal> command as not been supported in official releases.
</para>

<para>
<programlisting format="linespecific">
./configure --with-shared-modules=rpc,vfs,auth,pdb,charset
</programlisting>
</para>

</sect1>


</chapter>
</part>

</book>
