Goal: Fix process crush when using gethostbyname_r in several threads

Fixes: #509101, #510450

Status wrt upstream: Fixed in 3.2.6

Author: Jeremy Allison <jra@samba.org>

Note: This bug induces web browser crashes (see #510450) and is a regression
      for many desktop users in etch->lenny upgrades

Index: samba-3.2.5/source/nsswitch/wins.c
===================================================================
--- samba-3.2.5.orig/source/nsswitch/wins.c
+++ samba-3.2.5/source/nsswitch/wins.c
@@ -25,6 +25,14 @@
 #include <ns_daemon.h>
 #endif
 
+#if HAVE_PTHREAD_H
+#include <pthread.h>
+#endif
+
+#if HAVE_PTHREAD
+static pthread_mutex_t wins_nss_mutex = PTHREAD_MUTEX_INITIALIZER;
+#endif
+
 #ifndef INADDRSZ
 #define INADDRSZ 4
 #endif
@@ -321,11 +329,16 @@
 _nss_wins_gethostbyname_r(const char *hostname, struct hostent *he,
 			  char *buffer, size_t buflen, int *h_errnop)
 {
+	NSS_STATUS nss_status = NSS_STATUS_SUCCESS;
 	struct in_addr *ip_list;
 	int i, count;
 	fstring name;
 	size_t namelen;
 		
+#if HAVE_PTHREAD
+	pthread_mutex_lock(&wins_nss_mutex);
+#endif
+
 	memset(he, '\0', sizeof(*he));
 	fstrcpy(name, hostname);
 
@@ -333,8 +346,10 @@
 
 	ip_list = lookup_byname_backend(name, &count);
 
-	if (!ip_list)
-		return NSS_STATUS_NOTFOUND;
+	if (!ip_list) {
+		nss_status = NSS_STATUS_NOTFOUND;
+		goto out;
+	}
 
 	/* Copy h_name */
 
@@ -342,7 +357,8 @@
 
 	if ((he->h_name = get_static(&buffer, &buflen, namelen)) == NULL) {
 		free(ip_list);
-		return NSS_STATUS_TRYAGAIN;
+		nss_status = NSS_STATUS_TRYAGAIN;
+		goto out;
 	}
 
 	memcpy(he->h_name, name, namelen);
@@ -354,20 +370,23 @@
 
 	if (get_static(&buffer, &buflen, i) == NULL) {
 		free(ip_list);
-		return NSS_STATUS_TRYAGAIN;
+		nss_status = NSS_STATUS_TRYAGAIN;
+		goto out;
 	}
 
 	if ((he->h_addr_list = (char **)get_static(
 		     &buffer, &buflen, (count + 1) * sizeof(char *))) == NULL) {
 		free(ip_list);
-		return NSS_STATUS_TRYAGAIN;
+		nss_status = NSS_STATUS_TRYAGAIN;
+		goto out;
 	}
 
 	for (i = 0; i < count; i++) {
 		if ((he->h_addr_list[i] = get_static(&buffer, &buflen,
 						     INADDRSZ)) == NULL) {
 			free(ip_list);
-			return NSS_STATUS_TRYAGAIN;
+			nss_status = NSS_STATUS_TRYAGAIN;
+			goto out;
 		}
 		memcpy(he->h_addr_list[i], &ip_list[i], INADDRSZ);
 	}
@@ -386,16 +405,27 @@
 	if ((i = (unsigned long)(buffer) % sizeof(char*)) != 0)
 		i = sizeof(char*) - i;
 
-	if (get_static(&buffer, &buflen, i) == NULL)
-		return NSS_STATUS_TRYAGAIN;
+	if (get_static(&buffer, &buflen, i) == NULL) {
+		nss_status = NSS_STATUS_TRYAGAIN;
+		goto out;
+	}
 
 	if ((he->h_aliases = (char **)get_static(
-		     &buffer, &buflen, sizeof(char *))) == NULL)
-		return NSS_STATUS_TRYAGAIN;
+		     &buffer, &buflen, sizeof(char *))) == NULL) {
+		nss_status = NSS_STATUS_TRYAGAIN;
+		goto out;
+	}
 
 	he->h_aliases[0] = NULL;
 
-	return NSS_STATUS_SUCCESS;
+	nss_status = NSS_STATUS_SUCCESS;
+
+  out:
+
+#if HAVE_PTHREAD
+	pthread_mutex_unlock(&wins_nss_mutex);
+#endif
+	return nss_status;
 }
 
 
@@ -403,12 +433,15 @@
 _nss_wins_gethostbyname2_r(const char *name, int af, struct hostent *he,
 			   char *buffer, size_t buflen, int *h_errnop)
 {
+	NSS_STATUS nss_status;
+
 	if(af!=AF_INET) {
 		*h_errnop = NO_DATA;
-		return NSS_STATUS_UNAVAIL;
+		nss_status = NSS_STATUS_UNAVAIL;
+	} else {
+		nss_status = _nss_wins_gethostbyname_r(
+				name, he, buffer, buflen, h_errnop);
 	}
-
-	return _nss_wins_gethostbyname_r(
-		name, he, buffer, buflen, h_errnop);
+	return nss_status;
 }
 #endif
